(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/primo-events/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"eventable.js\"}\n//@ sourceURL=/node_modules/primo-events/package.json"
));

require.define("/node_modules/primo-events/eventable.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar EventContainer = require('./eventcontainer');\n  \nvar Eventable = function() {\n  this.eventListeners = {};\n  this.eventDepth = 0;\n  this.proxies = []\n};\n\nEventable.prototype = {\n  autoHook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.on(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  autoUnhook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.off(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  clearListeners: function() {\n    this.eventListeners = {};\n    this.eventDepth = 0;\n    this.proxies = []\n  },\n  once: function(eventName, callback, context) {\n    var self = this;\n    var wrappedCallback = function(data, sender) {\n      callback.call(this, data, sender);\n      self.off(eventName, wrappedCallback, context);\n    };\n    this.on(eventName, wrappedCallback, context);\n  },\n  \n  on: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).add(callback, context);\n  },\n  \n  off: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).remove(callback, context);\n  },\n  raise: function(eventName, data, sender) {\n    var container = this.eventListeners[eventName];\n\n    if(container)\n      container.raise(sender || this, data);\n\n    var proxies = this.proxies\n    for(var i = 0 ; i < proxies.length ; i++)\n      proxies[i].raise(eventName, data, sender || this)\n  },\n  addProxy: function(proxy) {\n    this.proxies.push(proxy)\n  },\n  removeProxy: function(proxy) {\n    this.proxies = _.without(this.proxies, proxy)\n  },\n  eventContainerFor: function(eventName) {\n    var container = this.eventListeners[eventName];\n    if(!container) {\n      container =  new EventContainer(this);\n      this.eventListeners[eventName] = container;\n    }\n    return container;\n  }\n};\n\nmodule.exports = Eventable;\n\n\n//@ sourceURL=/node_modules/primo-events/eventable.js"
));

require.define("/node_modules/underscore/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"underscore.js\"}\n//@ sourceURL=/node_modules/underscore/package.json"
));

require.define("/node_modules/underscore/underscore.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.4';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n//@ sourceURL=/node_modules/underscore/underscore.js"
));

require.define("/node_modules/primo-events/eventcontainer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore');\n\nvar EventContainer = function(defaultContext) {\n  this.handlers = [];\n  this.defaultContext = defaultContext;\n}; \n\nEventContainer.prototype = {\n  raise: function(source, data) {\n   var handlerLength = this.handlers.length;\n   var handlers = this.handlers\n   for(var i = 0; i < handlerLength; i++) {\n      var handler = handlers[i];\n      handler.method.call(handler.context || this.defaultContext, data, source);   \n   }\n  },\n  add: function(method, context) {\n    this.handlers.push({\n      method: method,\n      context: context      \n    });\n  },\n  remove: function(method, context) {\n    this.handlers = _(this.handlers).filter(function(item) {\n      return item.method !== method || item.context !== context;\n    });\n  }\n};\n  \nmodule.exports = EventContainer;\n\n//@ sourceURL=/node_modules/primo-events/eventcontainer.js"
));

require.define("/node_modules/primo-level/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"level.js\"}\n//@ sourceURL=/node_modules/primo-level/package.json"
));

require.define("/node_modules/primo-level/node_modules/primo-spritemap/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"spritemap.js\"}\n//@ sourceURL=/node_modules/primo-level/node_modules/primo-spritemap/package.json"
));

require.define("/node_modules/primo-level/node_modules/primo-spritemap/spritemap.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar MemoryCanvas = require('primo-canvas')\nvar Eventable = require('primo-events')\n\nvar SpriteMap = function(texture, tilecountwidth, tilecountheight) {\n  Eventable.call(this)\n  this.tilewidth = 0\n  this.tileheight = 0\n  this.tilecountwidth = tilecountwidth || 1\n  this.tilecountheight = tilecountheight || 1\n  this.tilecount = tilecountwidth * tilecountheight \n  this.collisionmapsize = 0\n  this.collisionMaps = []\n  this.texture = texture\n  this.loaded = false\n  this.texture.waitForLoaded(_.bind(this.onLoaded, this))\n}\n\nSpriteMap.prototype = {\n  drawTo: function(context, index,  x, y, width, height, flipx, flipy, rotation) {\n    if(!this.loaded) return\n\n    var img = this.texture.get()\n\n    var rownumber = Math.floor(index / this.tilecountwidth)\n    var columnnumber = index % this.tilecountwidth\n\n    var sx = columnnumber * this.tilewidth\n    var sy = rownumber * this.tileheight\n\n    var scalex = flipx ? -1 : 1\n    var scaley = flipy ? -1 : 1\n    var contextSaved = false\n\n    if(rotation) {\n      if(!contextSaved) {\n        contextSaved = true\n        context.save()\n      }\n      context.translate(x + width/2.0, y + height/2.0)\n      context.rotate(rotation)\n      context.translate(-(x + width/2.0),-(y + height/2.0))\n    }\n\n    if(flipx || flipy) {\n      if(!contextSaved) {\n        contextSaved = true\n        context.save()\n      }\n      context.scale(scalex, scaley)\n      x *= scalex\n      y *= scaley\n      if(flipx)\n        x -= width\n      if(flipy)\n        y -= height\n      contextSaved = true\n    } \n\n\n    context.drawImage(img, \n      sx, sy, this.tilewidth, this.tileheight,\n      x, y , width || this.tilewidth, height || this.tileheight)\n\n    if(contextSaved) \n      context.restore()\n  },\n  generateCollisionMaps: function(width, height) {\n    if(!this.loaded) \n      return this.once('loaded', \n        function() { \n          this.generateCollisionMaps(width, height) }, this)\n\n    // TODO: This doesn't really belong here, it needs storing elsewhere or returning\n    this.collisionmapsize = width\n    var canvas = new MemoryCanvas(width, height)\n\n    try {\n      for(var i = 0; i < this.tilecount ; i++) {\n        canvas.reset()\n        this.drawTo(canvas.context, i, 0, 0, width, height)\n        this.collisionMaps[i] = canvas.createMap()\n      }\n    }\n    catch(ex) {\n      throw ex\n    }\n    finally {\n      canvas.dispose()\n    }\n  },\n  hasPixelAt: function(index, x, y) {\n    if(!this.loaded) return false\n    var map = this.collisionMaps[index]\n    return map[x + y * this.collisionmapsize]\n  },\n  onLoaded: function() {\n    this.loaded = true\n    var img = this.texture.get()\n    this.tilewidth = img.width / this.tilecountwidth\n    this.tileheight = img.height / this.tilecountheight\n    this.raise('loaded')\n  }\n}\n_.extend(SpriteMap.prototype, Eventable.prototype)\n\nmodule.exports = SpriteMap\n\n//@ sourceURL=/node_modules/primo-level/node_modules/primo-spritemap/spritemap.js"
));

require.define("/node_modules/primo-level/node_modules/primo-spritemap/node_modules/underscore/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"underscore.js\"}\n//@ sourceURL=/node_modules/primo-level/node_modules/primo-spritemap/node_modules/underscore/package.json"
));

require.define("/node_modules/primo-level/node_modules/primo-spritemap/node_modules/underscore/underscore.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.4';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n//@ sourceURL=/node_modules/primo-level/node_modules/primo-spritemap/node_modules/underscore/underscore.js"
));

require.define("/node_modules/primo-level/node_modules/primo-spritemap/node_modules/primo-canvas/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"memorycanvas.js\"}\n//@ sourceURL=/node_modules/primo-level/node_modules/primo-spritemap/node_modules/primo-canvas/package.json"
));

require.define("/node_modules/primo-level/node_modules/primo-spritemap/node_modules/primo-canvas/memorycanvas.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var MemoryCanvas = function(width, height) {\n  this.width = width\n  this.height = height\n  this.canvas = document.createElement('canvas')\n  this.canvas.width = width \n  this.canvas.height = height \n  this.context = this.canvas.getContext('2d')\n}\nMemoryCanvas.prototype = {\n  reset: function() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0)\n    this.context.clearRect(0,0, this.width, this.height)\n  },\n  setup: function(width, height) {\n    this.reset()\n\n    var scalex = this.width / width\n      , scaley = this.height / height\n\n    this.context.scale(scalex, scaley)\n  },\n  getImage: function() {\n    return this.canvas.toDataURL()\n  },\n  createMap: function() {\n    var data = this.context.getImageData(0,0, this.width, this.height).data\n    var map = new Array(this.width * this.height)\n    for(var y = 0; y < this.height; y++) {\n      for(var x = 0; x < this.width; x++) {\n        var index = x + y*this.width\n        var pixelindex = index * 4\n        var total = data[pixelindex] + data[pixelindex+1] + data[pixelindex+2]\n        if(total)\n          map[index] = 1\n        else\n          map[index] = 0\n      }\n    }\n    return map\n  },\n  dispose: function() {\n    document.removeElement(this.canvas)\n  }\n}\nmodule.exports = MemoryCanvas\n\n//@ sourceURL=/node_modules/primo-level/node_modules/primo-spritemap/node_modules/primo-canvas/memorycanvas.js"
));

require.define("/node_modules/primo-level/node_modules/primo-spritemap/node_modules/primo-events/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"eventable.js\"}\n//@ sourceURL=/node_modules/primo-level/node_modules/primo-spritemap/node_modules/primo-events/package.json"
));

require.define("/node_modules/primo-level/node_modules/primo-spritemap/node_modules/primo-events/eventable.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar EventContainer = require('./eventcontainer');\n  \nvar Eventable = function() {\n  this.eventListeners = {};\n  this.eventDepth = 0;\n  this.proxies = []\n};\n\nEventable.prototype = {\n  autoHook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.on(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  autoUnhook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.off(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  clearListeners: function() {\n    this.eventListeners = {};\n    this.eventDepth = 0;\n    this.proxies = []\n  },\n  once: function(eventName, callback, context) {\n    var self = this;\n    var wrappedCallback = function(data, sender) {\n      callback.call(this, data, sender);\n      self.off(eventName, wrappedCallback, context);\n    };\n    this.on(eventName, wrappedCallback, context);\n  },\n  \n  on: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).add(callback, context);\n  },\n  \n  off: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).remove(callback, context);\n  },\n  raise: function(eventName, data, sender) {\n    var container = this.eventListeners[eventName];\n\n    if(container)\n      container.raise(sender || this, data);\n\n    var proxies = this.proxies\n    for(var i = 0 ; i < proxies.length ; i++)\n      proxies[i].raise(eventName, data, sender || this)\n  },\n  addProxy: function(proxy) {\n    this.proxies.push(proxy)\n  },\n  removeProxy: function(proxy) {\n    this.proxies = _.without(this.proxies, proxy)\n  },\n  eventContainerFor: function(eventName) {\n    var container = this.eventListeners[eventName];\n    if(!container) {\n      container =  new EventContainer(this);\n      this.eventListeners[eventName] = container;\n    }\n    return container;\n  }\n};\n\nmodule.exports = Eventable;\n\n\n//@ sourceURL=/node_modules/primo-level/node_modules/primo-spritemap/node_modules/primo-events/eventable.js"
));

require.define("/node_modules/primo-level/node_modules/primo-spritemap/node_modules/primo-events/eventcontainer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore');\n\nvar EventContainer = function(defaultContext) {\n  this.handlers = [];\n  this.defaultContext = defaultContext;\n}; \n\nEventContainer.prototype = {\n  raise: function(source, data) {\n   var handlerLength = this.handlers.length;\n   var handlers = this.handlers\n   for(var i = 0; i < handlerLength; i++) {\n      var handler = handlers[i];\n      handler.method.call(handler.context || this.defaultContext, data, source);   \n   }\n  },\n  add: function(method, context) {\n    this.handlers.push({\n      method: method,\n      context: context      \n    });\n  },\n  remove: function(method, context) {\n    this.handlers = _(this.handlers).filter(function(item) {\n      return item.method !== method || item.context !== context;\n    });\n  }\n};\n  \nmodule.exports = EventContainer;\n\n//@ sourceURL=/node_modules/primo-level/node_modules/primo-spritemap/node_modules/primo-events/eventcontainer.js"
));

require.define("/node_modules/primo-level/layer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var SpriteMap = require('primo-spritemap')\n\nvar Layer = function(level, index) {\n  this.level = level\n  this.config = this.level.layerdata(index)\n  this.index = index\n  this.hidden = false\n}\nLayer.prototype = {\n  name: function() {\n    return this.config.name\n  },\n  tileset: function() {\n    return this.level.tileset(this.config.tileset)\n  },\n  setTileAt: function(x, y, tile) {\n    this.level.setTileAt(this.index, x, y, tile)\n  },\n  getTileAt: function(x, y, tile) {\n    return this.level.getTileAt(this.index, x, y, tile)\n  },\n  iscollision: function(value) {\n    if(typeof value !== 'undefined') {\n      this.config.collision = value\n    }\n    return !!this.config.collision\n  },\n  solidAt: function(x, y) {\n    var tilex = parseInt( x / this.level.tilesize(), 10)\n    var tiley = parseInt( y / this.level.tilesize(), 10)\n    var remainderx = x % this.level.tilesize()\n    var remaindery = y % this.level.tilesize()\n\n    var index = this.config.data[tilex + tiley * this.level.width()]\n    if(index === null) return false\n    return this.spritemap().hasPixelAt(index, remainderx, remaindery)\n  },\n  hide: function() {\n    this.hidden = true\n  },\n  show: function() {\n    this.hidden = false\n  },\n  spritemap: function() {\n    return this.level.spritemap(this.config.tileset)\n  },\n  render: function(context) {\n    if(this.hidden) return\n    for(var x = 0; x < this.level.width() ; x++) {\n      for(var y = 0; y < this.level.height() ; y++) {\n        var index = x + (y * this.level.width())\n        var left = x * this.level.tilesize()\n        var top = y * this.level.tilesize()\n\n        if(this.config.data[index] === null)\n          continue\n\n        this.spritemap().drawTo(context, \n          this.config.data[index], \n          left, top, this.level.tilesize(), this.level.tilesize());\n      }\n    }\n  }\n}\nmodule.exports = Layer\n\n//@ sourceURL=/node_modules/primo-level/layer.js"
));

require.define("/node_modules/primo-level/node_modules/browser-request/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"browserify\":\"./dist/ender/request.js\"}\n//@ sourceURL=/node_modules/primo-level/node_modules/browser-request/package.json"
));

require.define("/node_modules/primo-level/node_modules/browser-request/dist/ender/request.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Browser Request\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar xmlhttprequest = require('./xmlhttprequest')\nif(!xmlhttprequest || typeof xmlhttprequest !== 'object')\n  throw new Error('Could not find ./xmlhttprequest')\n\nvar XHR = xmlhttprequest.XMLHttpRequest\nif(!XHR)\n  throw new Error('Bad xmlhttprequest.XMLHttpRequest')\nif(! ('_object' in (new XHR)))\n  throw new Error('This is not portable XMLHttpRequest')\n\nmodule.exports = request\nrequest.XMLHttpRequest = XHR\nrequest.log = getLogger()\n\nvar DEFAULT_TIMEOUT = 3 * 60 * 1000 // 3 minutes\n\n//\n// request\n//\n\nfunction request(options, callback) {\n  // The entry-point to the API: prep the options object and pass the real work to run_xhr.\n  if(typeof callback !== 'function')\n    throw new Error('Bad callback given: ' + callback)\n\n  if(!options)\n    throw new Error('No options given')\n\n  var options_onResponse = options.onResponse; // Save this for later.\n\n  if(typeof options === 'string')\n    options = {'uri':options};\n  else\n    options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.\n\n  options.onResponse = options_onResponse // And put it back.\n\n  if(options.url) {\n    options.uri = options.url;\n    delete options.url;\n  }\n\n  if(!options.uri && options.uri !== \"\")\n    throw new Error(\"options.uri is a required argument\");\n\n  if(typeof options.uri != \"string\")\n    throw new Error(\"options.uri must be a string\");\n\n  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect']\n  for (var i = 0; i < unsupported_options.length; i++)\n    if(options[ unsupported_options[i] ])\n      throw new Error(\"options.\" + unsupported_options[i] + \" is not supported\")\n\n  options.callback = callback\n  options.method = options.method || 'GET';\n  options.headers = options.headers || {};\n  options.body    = options.body || null\n  options.timeout = options.timeout || request.DEFAULT_TIMEOUT\n\n  if(options.headers.host)\n    throw new Error(\"Options.headers.host is not supported\");\n\n  if(options.json) {\n    options.headers.accept = options.headers.accept || 'application/json'\n    if(options.method !== 'GET')\n      options.headers['content-type'] = 'application/json'\n\n    if(typeof options.json !== 'boolean')\n      options.body = JSON.stringify(options.json)\n    else if(typeof options.body !== 'string')\n      options.body = JSON.stringify(options.body)\n  }\n\n  // If onResponse is boolean true, call back immediately when the response is known,\n  // not when the full request is complete.\n  options.onResponse = options.onResponse || noop\n  if(options.onResponse === true) {\n    options.onResponse = callback\n    options.callback = noop\n  }\n\n  // XXX Browsers do not like this.\n  //if(options.body)\n  //  options.headers['content-length'] = options.body.length;\n\n  // HTTP basic authentication\n  if(!options.headers.authorization && options.auth)\n    options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);\n\n  return run_xhr(options)\n}\n\nvar req_seq = 0\nfunction run_xhr(options) {\n  var xhr = new XHR\n    , timed_out = false\n    , is_cors = is_crossDomain(options.uri)\n    , supports_cors = ('withCredentials' in xhr._object)\n\n  req_seq += 1\n  xhr.seq_id = req_seq\n  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri\n  xhr._id = xhr.id // I know I will type \"_id\" from habit all the time.\n\n  if(is_cors && !supports_cors) {\n    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri)\n    cors_err.cors = 'unsupported'\n    return options.callback(cors_err, xhr)\n  }\n\n  xhr.timeoutTimer = setTimeout(too_late, options.timeout)\n  function too_late() {\n    timed_out = true\n    var er = new Error('ETIMEDOUT')\n    er.code = 'ETIMEDOUT'\n    er.duration = options.timeout\n\n    request.log.error('Timeout', { 'id':xhr._id, 'milliseconds':options.timeout })\n    return options.callback(er, xhr)\n  }\n\n  // Some states can be skipped over, so remember what is still incomplete.\n  var did = {'response':false, 'loading':false, 'end':false}\n\n  xhr.onreadystatechange = on_state_change\n  xhr.open(options.method, options.uri, true) // asynchronous\n  if(is_cors)\n    xhr._object.withCredentials = !! options.withCredentials\n  xhr.send(options.body)\n  return xhr\n\n  function on_state_change(event) {\n    if(timed_out)\n      return request.log.debug('Ignoring timed out state change', {'state':xhr.readyState, 'id':xhr.id})\n\n    request.log.debug('State change', {'state':xhr.readyState, 'id':xhr.id, 'timed_out':timed_out})\n\n    if(xhr.readyState === XHR.OPENED) {\n      request.log.debug('Request started', {'id':xhr.id})\n      for (var key in options.headers)\n        xhr.setRequestHeader(key, options.headers[key])\n    }\n\n    else if(xhr.readyState === XHR.HEADERS_RECEIVED)\n      on_response()\n\n    else if(xhr.readyState === XHR.LOADING) {\n      on_response()\n      on_loading()\n    }\n\n    else if(xhr.readyState === XHR.DONE) {\n      on_response()\n      on_loading()\n      on_end()\n    }\n  }\n\n  function on_response() {\n    if(did.response)\n      return\n\n    did.response = true\n    request.log.debug('Got response', {'id':xhr.id, 'status':xhr.status})\n    clearTimeout(xhr.timeoutTimer)\n    xhr.statusCode = xhr.status // Node request compatibility\n\n    // Detect failed CORS requests.\n    if(is_cors && xhr.statusCode == 0) {\n      var cors_err = new Error('CORS request rejected: ' + options.uri)\n      cors_err.cors = 'rejected'\n\n      // Do not process this request further.\n      did.loading = true\n      did.end = true\n\n      return options.callback(cors_err, xhr)\n    }\n\n    options.onResponse(null, xhr)\n  }\n\n  function on_loading() {\n    if(did.loading)\n      return\n\n    did.loading = true\n    request.log.debug('Response body loading', {'id':xhr.id})\n    // TODO: Maybe simulate \"data\" events by watching xhr.responseText\n  }\n\n  function on_end() {\n    if(did.end)\n      return\n\n    did.end = true\n    request.log.debug('Request done', {'id':xhr.id})\n\n    xhr.body = xhr.responseText\n    if(options.json) {\n      try        { xhr.body = JSON.parse(xhr.responseText) }\n      catch (er) { return options.callback(er, xhr)        }\n    }\n\n    options.callback(null, xhr, xhr.body)\n  }\n\n} // request\n\nrequest.withCredentials = false;\nrequest.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;\n\n//\n// HTTP method shortcuts\n//\n\nvar shortcuts = [ 'get', 'put', 'post', 'head' ];\nshortcuts.forEach(function(shortcut) {\n  var method = shortcut.toUpperCase();\n  var func   = shortcut.toLowerCase();\n\n  request[func] = function(opts) {\n    if(typeof opts === 'string')\n      opts = {'method':method, 'uri':opts};\n    else {\n      opts = JSON.parse(JSON.stringify(opts));\n      opts.method = method;\n    }\n\n    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));\n    return request.apply(this, args);\n  }\n})\n\n//\n// CouchDB shortcut\n//\n\nrequest.couch = function(options, callback) {\n  if(typeof options === 'string')\n    options = {'uri':options}\n\n  // Just use the request API to do JSON.\n  options.json = true\n  if(options.body)\n    options.json = options.body\n  delete options.body\n\n  callback = callback || noop\n\n  var xhr = request(options, couch_handler)\n  return xhr\n\n  function couch_handler(er, resp, body) {\n    if(er)\n      return callback(er, resp, body)\n\n    if((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {\n      // The body is a Couch JSON object indicating the error.\n      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error))\n      for (var key in body)\n        er[key] = body[key]\n      return callback(er, resp, body);\n    }\n\n    return callback(er, resp, body);\n  }\n}\n\n//\n// Utility\n//\n\nfunction noop() {}\n\nfunction getLogger() {\n  var logger = {}\n    , levels = ['trace', 'debug', 'info', 'warn', 'error']\n    , level, i\n\n  for(i = 0; i < levels.length; i++) {\n    level = levels[i]\n\n    logger[level] = noop\n    if(typeof console !== 'undefined' && console && console[level])\n      logger[level] = formatted(console, level)\n  }\n\n  return logger\n}\n\nfunction formatted(obj, method) {\n  return formatted_logger\n\n  function formatted_logger(str, context) {\n    if(typeof context === 'object')\n      str += ' ' + JSON.stringify(context)\n\n    return obj[method].call(obj, str)\n  }\n}\n\n// Return whether a URL is a cross-domain request.\nfunction is_crossDomain(url) {\n  var rurl = /^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+))?)?/\n\n  // jQuery #8138, IE may throw an exception when accessing\n  // a field from window.location if document.domain has been set\n  var ajaxLocation\n  try { ajaxLocation = location.href }\n  catch (e) {\n    // Use the href attribute of an A element since IE will modify it given document.location\n    ajaxLocation = document.createElement( \"a\" );\n    ajaxLocation.href = \"\";\n    ajaxLocation = ajaxLocation.href;\n  }\n\n  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []\n    , parts = rurl.exec(url.toLowerCase() )\n\n  var result = !!(\n    parts &&\n    (  parts[1] != ajaxLocParts[1]\n    || parts[2] != ajaxLocParts[2]\n    || (parts[3] || (parts[1] === \"http:\" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? 80 : 443))\n    )\n  )\n\n  //console.debug('is_crossDomain('+url+') -> ' + result)\n  return result\n}\n\n// MIT License from http://phpjs.org/functions/base64_encode:358\nfunction b64_enc (data) {\n    // Encodes string using MIME base64 algorithm\n    var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc=\"\", tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n    // assume utf8 data\n    // data = this.utf8_encode(data+'');\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1<<16 | o2<<8 | o3;\n\n        h1 = bits>>18 & 0x3f;\n        h2 = bits>>12 & 0x3f;\n        h3 = bits>>6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n        break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n        break;\n    }\n\n    return enc;\n}\n\n//@ sourceURL=/node_modules/primo-level/node_modules/browser-request/dist/ender/request.js"
));

require.define("/node_modules/primo-level/node_modules/browser-request/dist/ender/xmlhttprequest.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n\n!function(window) {\n  if(typeof exports === 'undefined')\n    throw new Error('Cannot find global \"exports\" object. Is this really CommonJS?')\n  if(typeof module === 'undefined')\n    throw new Error('Cannot find global \"module\" object. Is this really CommonJS?')\n  if(!module.exports)\n    throw new Error('Cannot find global \"module.exports\" object. Is this really CommonJS?')\n\n  // Define globals to simulate a browser environment.\n  window = window || {}\n\n  var document = window.document || {}\n  if(!window.document)\n    window.document = document\n\n  var navigator = window.navigator || {}\n  if(!window.navigator)\n    window.navigator = navigator\n\n  if(!navigator.userAgent)\n    navigator.userAgent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/534.51.22 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22';\n\n  // Remember the old values in window. If the inner code changes anything, export that as a module and restore the old window value.\n  var win = {}\n    , key\n\n  for (key in window)\n    if(window.hasOwnProperty(key))\n      win[key] = window[key]\n\n  run_code()\n\n  for (key in window)\n    if(window.hasOwnProperty(key))\n      if(window[key] !== win[key]) {\n        exports[key] = window[key]\n        window[key] = win[key]\n      }\n\n  function run_code() {\n    // Begin browser file: XMLHttpRequest.js\n/**\n* XMLHttpRequest.js Copyright (C) 2011 Sergey Ilinsky (http://www.ilinsky.com)\n*\n* This work is free software; you can redistribute it and/or modify\n* it under the terms of the GNU Lesser General Public License as published by\n* the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This work is distributed in the hope that it will be useful,\n* but without any warranty; without even the implied warranty of\n* merchantability or fitness for a particular purpose. See the\n* GNU Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the Free Software Foundation, Inc.,\n* 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n(function () {\n\n\t// Save reference to earlier defined object implementation (if any)\n\tvar oXMLHttpRequest = window.XMLHttpRequest;\n\n\t// Define on browser type\n\tvar bGecko  = !!window.controllers;\n\tvar bIE     = !!window.document.namespaces;\n\tvar bIE7    = bIE && window.navigator.userAgent.match(/MSIE 7.0/);\n\n\t// Enables \"XMLHttpRequest()\" call next to \"new XMLHttpRequest()\"\n\tfunction fXMLHttpRequest() {\n\t\tthis._object  = oXMLHttpRequest && !bIE7 ? new oXMLHttpRequest : new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n\t\tthis._listeners = [];\n\t}\n\n\t// Constructor\n\tfunction cXMLHttpRequest() {\n\t\treturn new fXMLHttpRequest;\n\t}\n\tcXMLHttpRequest.prototype = fXMLHttpRequest.prototype;\n\n\t// BUGFIX: Firefox with Firebug installed would break pages if not executed\n\tif (bGecko && oXMLHttpRequest.wrapped) {\n\t\tcXMLHttpRequest.wrapped = oXMLHttpRequest.wrapped;\n\t}\n\n\t// Constants\n\tcXMLHttpRequest.UNSENT            = 0;\n\tcXMLHttpRequest.OPENED            = 1;\n\tcXMLHttpRequest.HEADERS_RECEIVED  = 2;\n\tcXMLHttpRequest.LOADING           = 3;\n\tcXMLHttpRequest.DONE              = 4;\n\n\t// Interface level constants\n\tcXMLHttpRequest.prototype.UNSENT            = cXMLHttpRequest.UNSENT;\n\tcXMLHttpRequest.prototype.OPENED            = cXMLHttpRequest.OPENED;\n\tcXMLHttpRequest.prototype.HEADERS_RECEIVED  = cXMLHttpRequest.HEADERS_RECEIVED;\n\tcXMLHttpRequest.prototype.LOADING           = cXMLHttpRequest.LOADING;\n\tcXMLHttpRequest.prototype.DONE              = cXMLHttpRequest.DONE;\n\n\t// Public Properties\n\tcXMLHttpRequest.prototype.readyState    = cXMLHttpRequest.UNSENT;\n\tcXMLHttpRequest.prototype.responseText  = '';\n\tcXMLHttpRequest.prototype.responseXML   = null;\n\tcXMLHttpRequest.prototype.status        = 0;\n\tcXMLHttpRequest.prototype.statusText    = '';\n\n\t// Priority proposal\n\tcXMLHttpRequest.prototype.priority    = \"NORMAL\";\n\n\t// Instance-level Events Handlers\n\tcXMLHttpRequest.prototype.onreadystatechange  = null;\n\n\t// Class-level Events Handlers\n\tcXMLHttpRequest.onreadystatechange  = null;\n\tcXMLHttpRequest.onopen              = null;\n\tcXMLHttpRequest.onsend              = null;\n\tcXMLHttpRequest.onabort             = null;\n\n\t// Public Methods\n\tcXMLHttpRequest.prototype.open  = function(sMethod, sUrl, bAsync, sUser, sPassword) {\n\t\t// http://www.w3.org/TR/XMLHttpRequest/#the-open-method\n\t\tvar sLowerCaseMethod = sMethod.toLowerCase();\n\t\tif (sLowerCaseMethod == \"connect\" || sLowerCaseMethod == \"trace\" || sLowerCaseMethod == \"track\") {\n\t\t\t// Using a generic error and an int - not too sure all browsers support correctly\n\t\t\t// http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#securityerror, so, this is safer\n\t\t\t// XXX should do better than that, but this is OT to XHR.\n\t\t\tthrow new Error(18);\n\t\t}\n\n\t\t// Delete headers, required when object is reused\n\t\tdelete this._headers;\n\n\t\t// When bAsync parameter value is omitted, use true as default\n\t\tif (arguments.length < 3) {\n\t\t\tbAsync  = true;\n\t\t}\n\n\t\t// Save async parameter for fixing Gecko bug with missing readystatechange in synchronous requests\n\t\tthis._async   = bAsync;\n\n\t\t// Set the onreadystatechange handler\n\t\tvar oRequest  = this;\n\t\tvar nState    = this.readyState;\n\t\tvar fOnUnload = null;\n\n\t\t// BUGFIX: IE - memory leak on page unload (inter-page leak)\n\t\tif (bIE && bAsync) {\n\t\t\tfOnUnload = function() {\n\t\t\t\tif (nState != cXMLHttpRequest.DONE) {\n\t\t\t\t\tfCleanTransport(oRequest);\n\t\t\t\t\t// Safe to abort here since onreadystatechange handler removed\n\t\t\t\t\toRequest.abort();\n\t\t\t\t}\n\t\t\t};\n\t\t\twindow.attachEvent(\"onunload\", fOnUnload);\n\t\t}\n\n\t\t// Add method sniffer\n\t\tif (cXMLHttpRequest.onopen) {\n\t\t\tcXMLHttpRequest.onopen.apply(this, arguments);\n\t\t}\n\n\t\tif (arguments.length > 4) {\n\t\t\tthis._object.open(sMethod, sUrl, bAsync, sUser, sPassword);\n\t\t} else if (arguments.length > 3) {\n\t\t\tthis._object.open(sMethod, sUrl, bAsync, sUser);\n\t\t} else {\n\t\t\tthis._object.open(sMethod, sUrl, bAsync);\n\t\t}\n\n\t\tthis.readyState = cXMLHttpRequest.OPENED;\n\t\tfReadyStateChange(this);\n\n\t\tthis._object.onreadystatechange = function() {\n\t\t\tif (bGecko && !bAsync) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Synchronize state\n\t\t\toRequest.readyState   = oRequest._object.readyState;\n\t\t\tfSynchronizeValues(oRequest);\n\n\t\t\t// BUGFIX: Firefox fires unnecessary DONE when aborting\n\t\t\tif (oRequest._aborted) {\n\t\t\t\t// Reset readyState to UNSENT\n\t\t\t\toRequest.readyState = cXMLHttpRequest.UNSENT;\n\n\t\t\t\t// Return now\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (oRequest.readyState == cXMLHttpRequest.DONE) {\n\t\t\t\t// Free up queue\n\t\t\t\tdelete oRequest._data;\n\n\t\t\t\t// Uncomment these lines for bAsync\n\t\t\t\t/**\n\t\t\t\t * if (bAsync) {\n\t\t\t\t * \tfQueue_remove(oRequest);\n\t\t\t\t * }\n\t\t\t\t */\n\n\t\t\t\tfCleanTransport(oRequest);\n\n\t\t\t\t// Uncomment this block if you need a fix for IE cache\n\t\t\t\t/**\n\t\t\t\t * // BUGFIX: IE - cache issue\n\t\t\t\t * if (!oRequest._object.getResponseHeader(\"Date\")) {\n\t\t\t\t * \t// Save object to cache\n\t\t\t\t * \toRequest._cached  = oRequest._object;\n\t\t\t\t *\n\t\t\t\t * \t// Instantiate a new transport object\n\t\t\t\t * \tcXMLHttpRequest.call(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t// Re-send request\n\t\t\t\t * \tif (sUser) {\n\t\t\t\t * \t\tif (sPassword) {\n\t\t\t\t * \t\t\toRequest._object.open(sMethod, sUrl, bAsync, sUser, sPassword);\n\t\t\t\t * \t\t} else {\n\t\t\t\t * \t\t\toRequest._object.open(sMethod, sUrl, bAsync);\n\t\t\t\t * \t\t}\n\t\t\t\t *\n\t\t\t\t * \t\toRequest._object.setRequestHeader(\"If-Modified-Since\", oRequest._cached.getResponseHeader(\"Last-Modified\") || new window.Date(0));\n\t\t\t\t * \t\t// Copy headers set\n\t\t\t\t * \t\tif (oRequest._headers) {\n\t\t\t\t * \t\t\tfor (var sHeader in oRequest._headers) {\n\t\t\t\t * \t\t\t\t// Some frameworks prototype objects with functions\n\t\t\t\t * \t\t\t\tif (typeof oRequest._headers[sHeader] == \"string\") {\n\t\t\t\t * \t\t\t\t\toRequest._object.setRequestHeader(sHeader, oRequest._headers[sHeader]);\n\t\t\t\t * \t\t\t\t}\n\t\t\t\t * \t\t\t}\n\t\t\t\t * \t\t}\n\t\t\t\t * \t\toRequest._object.onreadystatechange = function() {\n\t\t\t\t * \t\t\t// Synchronize state\n\t\t\t\t * \t\t\toRequest.readyState   = oRequest._object.readyState;\n\t\t\t\t *\n\t\t\t\t * \t\t\tif (oRequest._aborted) {\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\toRequest.readyState = cXMLHttpRequest.UNSENT;\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t// Return\n\t\t\t\t * \t\t\t\treturn;\n\t\t\t\t * \t\t\t}\n\t\t\t\t *\n\t\t\t\t * \t\t\tif (oRequest.readyState == cXMLHttpRequest.DONE) {\n\t\t\t\t * \t\t\t\t// Clean Object\n\t\t\t\t * \t\t\t\tfCleanTransport(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t// get cached request\n\t\t\t\t * \t\t\t\tif (oRequest.status == 304) {\n\t\t\t\t * \t\t\t\t\toRequest._object  = oRequest._cached;\n\t\t\t\t * \t\t\t\t}\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\tdelete oRequest._cached;\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\tfSynchronizeValues(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\tfReadyStateChange(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t// BUGFIX: IE - memory leak in interrupted\n\t\t\t\t * \t\t\t\tif (bIE && bAsync) {\n\t\t\t\t * \t\t\t\t\twindow.detachEvent(\"onunload\", fOnUnload);\n\t\t\t\t * \t\t\t\t}\n\t\t\t\t *\n\t\t\t\t * \t\t\t}\n\t\t\t\t * \t\t};\n\t\t\t\t * \t\toRequest._object.send(null);\n\t\t\t\t *\n\t\t\t\t * \t\t// Return now - wait until re-sent request is finished\n\t\t\t\t * \t\treturn;\n\t\t\t\t * \t};\n\t\t\t\t */\n\n\t\t\t\t// BUGFIX: IE - memory leak in interrupted\n\t\t\t\tif (bIE && bAsync) {\n\t\t\t\t\twindow.detachEvent(\"onunload\", fOnUnload);\n\t\t\t\t}\n\n\t\t\t\t// BUGFIX: Some browsers (Internet Explorer, Gecko) fire OPEN readystate twice\n\t\t\t\tif (nState != oRequest.readyState) {\n\t\t\t\t\tfReadyStateChange(oRequest);\n\t\t\t\t}\n\n\t\t\t\tnState  = oRequest.readyState;\n\t\t\t}\n\t\t};\n\t};\n\n\tcXMLHttpRequest.prototype.send = function(vData) {\n\t\t// Add method sniffer\n\t\tif (cXMLHttpRequest.onsend) {\n\t\t\tcXMLHttpRequest.onsend.apply(this, arguments);\n\t\t}\n\n\t\tif (!arguments.length) {\n\t\t\tvData = null;\n\t\t}\n\n\t\t// BUGFIX: Safari - fails sending documents created/modified dynamically, so an explicit serialization required\n\t\t// BUGFIX: IE - rewrites any custom mime-type to \"text/xml\" in case an XMLNode is sent\n\t\t// BUGFIX: Gecko - fails sending Element (this is up to the implementation either to standard)\n\t\tif (vData && vData.nodeType) {\n\t\t\tvData = window.XMLSerializer ? new window.XMLSerializer().serializeToString(vData) : vData.xml;\n\t\t\tif (!this._headers[\"Content-Type\"]) {\n\t\t\t\tthis._object.setRequestHeader(\"Content-Type\", \"application/xml\");\n\t\t\t}\n\t\t}\n\n\t\tthis._data = vData;\n\n\t\t/**\n\t\t * // Add to queue\n\t\t * if (this._async) {\n\t\t * \tfQueue_add(this);\n\t\t * } else { */\n\t\tfXMLHttpRequest_send(this);\n\t\t /**\n\t\t * }\n\t\t */\n\t};\n\n\tcXMLHttpRequest.prototype.abort = function() {\n\t\t// Add method sniffer\n\t\tif (cXMLHttpRequest.onabort) {\n\t\t\tcXMLHttpRequest.onabort.apply(this, arguments);\n\t\t}\n\n\t\t// BUGFIX: Gecko - unnecessary DONE when aborting\n\t\tif (this.readyState > cXMLHttpRequest.UNSENT) {\n\t\t\tthis._aborted = true;\n\t\t}\n\n\t\tthis._object.abort();\n\n\t\t// BUGFIX: IE - memory leak\n\t\tfCleanTransport(this);\n\n\t\tthis.readyState = cXMLHttpRequest.UNSENT;\n\n\t\tdelete this._data;\n\n\t\t/* if (this._async) {\n\t \t* \tfQueue_remove(this);\n\t \t* }\n\t \t*/\n\t};\n\n\tcXMLHttpRequest.prototype.getAllResponseHeaders = function() {\n\t\treturn this._object.getAllResponseHeaders();\n\t};\n\n\tcXMLHttpRequest.prototype.getResponseHeader = function(sName) {\n\t\treturn this._object.getResponseHeader(sName);\n\t};\n\n\tcXMLHttpRequest.prototype.setRequestHeader  = function(sName, sValue) {\n\t\t// BUGFIX: IE - cache issue\n\t\tif (!this._headers) {\n\t\t\tthis._headers = {};\n\t\t}\n\n\t\tthis._headers[sName]  = sValue;\n\n\t\treturn this._object.setRequestHeader(sName, sValue);\n\t};\n\n\t// EventTarget interface implementation\n\tcXMLHttpRequest.prototype.addEventListener  = function(sName, fHandler, bUseCapture) {\n\t\tfor (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {\n\t\t\tif (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Add listener\n\t\tthis._listeners.push([sName, fHandler, bUseCapture]);\n\t};\n\n\tcXMLHttpRequest.prototype.removeEventListener = function(sName, fHandler, bUseCapture) {\n\t\tfor (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {\n\t\t\tif (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Remove listener\n\t\tif (oListener) {\n\t\t\tthis._listeners.splice(nIndex, 1);\n\t\t}\n\t};\n\n\tcXMLHttpRequest.prototype.dispatchEvent = function(oEvent) {\n\t\tvar oEventPseudo  = {\n\t\t\t'type':             oEvent.type,\n\t\t\t'target':           this,\n\t\t\t'currentTarget':    this,\n\t\t\t'eventPhase':       2,\n\t\t\t'bubbles':          oEvent.bubbles,\n\t\t\t'cancelable':       oEvent.cancelable,\n\t\t\t'timeStamp':        oEvent.timeStamp,\n\t\t\t'stopPropagation':  function() {},  // There is no flow\n\t\t\t'preventDefault':   function() {},  // There is no default action\n\t\t\t'initEvent':        function() {}   // Original event object should be initialized\n\t\t};\n\n\t\t// Execute onreadystatechange\n\t\tif (oEventPseudo.type == \"readystatechange\" && this.onreadystatechange) {\n\t\t\t(this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [oEventPseudo]);\n\t\t}\n\n\n\t\t// Execute listeners\n\t\tfor (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {\n\t\t\tif (oListener[0] == oEventPseudo.type && !oListener[2]) {\n\t\t\t\t(oListener[1].handleEvent || oListener[1]).apply(this, [oEventPseudo]);\n\t\t\t}\n\t\t}\n\n\t};\n\n\t//\n\tcXMLHttpRequest.prototype.toString  = function() {\n\t\treturn '[' + \"object\" + ' ' + \"XMLHttpRequest\" + ']';\n\t};\n\n\tcXMLHttpRequest.toString  = function() {\n\t\treturn '[' + \"XMLHttpRequest\" + ']';\n\t};\n\n\t/**\n\t * // Queue manager\n\t * var oQueuePending = {\"CRITICAL\":[],\"HIGH\":[],\"NORMAL\":[],\"LOW\":[],\"LOWEST\":[]},\n\t * aQueueRunning = [];\n\t * function fQueue_add(oRequest) {\n\t * \toQueuePending[oRequest.priority in oQueuePending ? oRequest.priority : \"NORMAL\"].push(oRequest);\n\t * \t//\n\t * \tsetTimeout(fQueue_process);\n\t * };\n\t *\n\t * function fQueue_remove(oRequest) {\n\t * \tfor (var nIndex = 0, bFound = false; nIndex < aQueueRunning.length; nIndex++)\n\t * \tif (bFound) {\n\t * \t\taQueueRunning[nIndex - 1] = aQueueRunning[nIndex];\n\t * \t} else {\n\t * \t\tif (aQueueRunning[nIndex] == oRequest) {\n\t * \t\t\tbFound  = true;\n\t * \t\t}\n\t * }\n\t *\n\t * \tif (bFound) {\n\t * \t\taQueueRunning.length--;\n\t * \t}\n\t *\n\t *\n\t * \t//\n\t * \tsetTimeout(fQueue_process);\n\t * };\n\t *\n\t * function fQueue_process() {\n\t * if (aQueueRunning.length < 6) {\n\t * for (var sPriority in oQueuePending) {\n\t * if (oQueuePending[sPriority].length) {\n\t * var oRequest  = oQueuePending[sPriority][0];\n\t * oQueuePending[sPriority]  = oQueuePending[sPriority].slice(1);\n\t * //\n\t * aQueueRunning.push(oRequest);\n\t * // Send request\n\t * fXMLHttpRequest_send(oRequest);\n\t * break;\n\t * }\n\t * }\n\t * }\n\t * };\n\t */\n\n\t// Helper function\n\tfunction fXMLHttpRequest_send(oRequest) {\n\t\toRequest._object.send(oRequest._data);\n\n\t\t// BUGFIX: Gecko - missing readystatechange calls in synchronous requests\n\t\tif (bGecko && !oRequest._async) {\n\t\t\toRequest.readyState = cXMLHttpRequest.OPENED;\n\n\t\t\t// Synchronize state\n\t\t\tfSynchronizeValues(oRequest);\n\n\t\t\t// Simulate missing states\n\t\t\twhile (oRequest.readyState < cXMLHttpRequest.DONE) {\n\t\t\t\toRequest.readyState++;\n\t\t\t\tfReadyStateChange(oRequest);\n\t\t\t\t// Check if we are aborted\n\t\t\t\tif (oRequest._aborted) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction fReadyStateChange(oRequest) {\n\t\t// Sniffing code\n\t\tif (cXMLHttpRequest.onreadystatechange){\n\t\t\tcXMLHttpRequest.onreadystatechange.apply(oRequest);\n\t\t}\n\n\n\t\t// Fake event\n\t\toRequest.dispatchEvent({\n\t\t\t'type':       \"readystatechange\",\n\t\t\t'bubbles':    false,\n\t\t\t'cancelable': false,\n\t\t\t'timeStamp':  new Date + 0\n\t\t});\n\t}\n\n\tfunction fGetDocument(oRequest) {\n\t\tvar oDocument = oRequest.responseXML;\n\t\tvar sResponse = oRequest.responseText;\n\t\t// Try parsing responseText\n\t\tif (bIE && sResponse && oDocument && !oDocument.documentElement && oRequest.getResponseHeader(\"Content-Type\").match(/[^\\/]+\\/[^\\+]+\\+xml/)) {\n\t\t\toDocument = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n\t\t\toDocument.async       = false;\n\t\t\toDocument.validateOnParse = false;\n\t\t\toDocument.loadXML(sResponse);\n\t\t}\n\n\t\t// Check if there is no error in document\n\t\tif (oDocument){\n\t\t\tif ((bIE && oDocument.parseError !== 0) || !oDocument.documentElement || (oDocument.documentElement && oDocument.documentElement.tagName == \"parsererror\")) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn oDocument;\n\t}\n\n\tfunction fSynchronizeValues(oRequest) {\n\t\ttry { oRequest.responseText = oRequest._object.responseText;  } catch (e) {}\n\t\ttry { oRequest.responseXML  = fGetDocument(oRequest._object); } catch (e) {}\n\t\ttry { oRequest.status       = oRequest._object.status;        } catch (e) {}\n\t\ttry { oRequest.statusText   = oRequest._object.statusText;    } catch (e) {}\n\t}\n\n\tfunction fCleanTransport(oRequest) {\n\t\t// BUGFIX: IE - memory leak (on-page leak)\n\t\toRequest._object.onreadystatechange = new window.Function;\n\t}\n\n\t// Internet Explorer 5.0 (missing apply)\n\tif (!window.Function.prototype.apply) {\n\t\twindow.Function.prototype.apply = function(oRequest, oArguments) {\n\t\t\tif (!oArguments) {\n\t\t\t\toArguments  = [];\n\t\t\t}\n\t\t\toRequest.__func = this;\n\t\t\toRequest.__func(oArguments[0], oArguments[1], oArguments[2], oArguments[3], oArguments[4]);\n\t\t\tdelete oRequest.__func;\n\t\t};\n\t}\n\n\t// Register new object with window\n\twindow.XMLHttpRequest = cXMLHttpRequest;\n\n})();\n\n    // End browser file: XMLHttpRequest.js\n  }\n}(typeof window !== 'undefined' ? window : {});\n\n//@ sourceURL=/node_modules/primo-level/node_modules/browser-request/dist/ender/xmlhttprequest.js"
));

require.define("/node_modules/primo/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/primo/package.json"
));

require.define("/node_modules/primo/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Entity = require('./lib/entity')\nvar Game = require('./lib/game')\n\nmodule.exports = {\n  DefineEntity: Entity.Define,\n  Create: function(targetId) {\n    return new Game(targetId)\n  }\n\n}\n\n//@ sourceURL=/node_modules/primo/index.js"
));

require.define("/node_modules/primo/lib/entity.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore') \nvar util = require('primo-utils')\nvar Eventable = require('primo-events')\n\nvar Entity = function(id,data, scene) {\n  Eventable.call(this)\n  this.id = id\n  data = data || {}\n  this.x = util.valueOrDefault(data.x, 0)\n  this.y = util.valueOrDefault(data.y, 0)\n  this.rotation = 0\n  this.lastx = this.x\n  this.lasty = this.y\n  this.velx = util.valueOrDefault(data.velx, 0)\n  this.vely = util.valueOrDefault(data.vely, 0)\n  this.rotvel = util.valueOrDefault(data.rotvel, 0)\n  this.width = util.valueOrDefault(data.width, 0)\n  this.height = util.valueOrDefault(data.height, 0)\n  this.gravible = false\n  this.scene = scene\n  this.game = scene.game\n  this.components = []\n  this.commandHandlers = {}\n  this.dispatch = _.bind(this.dispatch, this)\n}\n\nEntity.prototype = {\n  attach: function(component) {\n    this.components.push(component)\n    return component\n  },\n  tick: function(frameTime) {\n    this.raise('tick', frameTime)\n    _(this.components).each(function(c) { if(c.tick) c.tick(frameTime) })\n    //this.checkAgainstLevel()\n  },\n  render: function(context) {\n    _(this.components).each(function(c) { if(c.render) c.render(context) })\n  },\n  handle: function(command, cb) {\n    this.commandHandlers[command] = cb\n  },\n  dispatch: function(command, data) {\n    var handler = this.commandHandlers[command]\n    if(!handler)\n      console.warn('No handler registered for command', command)\n    else\n      handler(data)\n  },\n  applyPhysics: function(frameTime) {\n    this.scene.applyGravityTo(this)\n    this.lastx = this.x\n    this.lasty = this.y\n    this.x += this.velx * frameTime\n    this.y += this.vely * frameTime\n    this.rotation += this.rotvel * frameTime\n    this.scene.applyGravityTo(this)\n  },\n\n  kill: function() {\n    this.raise('killed')\n    this.scene.removeEntity(this)\n  }\n}\n\nEntity.Define = function(init, methods) {\n  var Ctor = function(id, data, game) {\n    Entity.call(this, id, data, game)\n    init.call(this, id, data)\n  }\n  _.extend(Ctor.prototype, Entity.prototype)\n  if(methods)\n    _.extend(Ctor.prototype, methods)\n  return Ctor\n}\n_.extend(Entity.prototype, Eventable.prototype)\n\nmodule.exports = Entity\n\n//@ sourceURL=/node_modules/primo/lib/entity.js"
));

require.define("/node_modules/primo/node_modules/underscore/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"underscore.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/underscore/package.json"
));

require.define("/node_modules/primo/node_modules/underscore/underscore.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     Underscore.js 1.4.3\n//     http://underscorejs.org\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // with specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    if (_.isEmpty(attrs)) return [];\n    return _.filter(obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + (0 | Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = '' + ++idCounter;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n//@ sourceURL=/node_modules/primo/node_modules/underscore/underscore.js"
));

require.define("/node_modules/primo/node_modules/primo-utils/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"commons.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-utils/package.json"
));

require.define("/node_modules/primo/node_modules/primo-utils/commons.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\n  valueOrDefault: function(value, def) {\n    return typeof value !== 'undefined' ? \n         value : \n         def\n  }\n}\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-utils/commons.js"
));

require.define("/node_modules/primo/node_modules/primo-events/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"eventable.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-events/package.json"
));

require.define("/node_modules/primo/node_modules/primo-events/eventable.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar EventContainer = require('./eventcontainer');\n  \nvar Eventable = function() {\n  this.eventListeners = {};\n  this.eventDepth = 0;\n  this.proxies = []\n};\n\nEventable.prototype = {\n  autoHook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.on(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  autoUnhook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.off(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  clearListeners: function() {\n    this.eventListeners = {};\n    this.eventDepth = 0;\n    this.proxies = []\n  },\n  once: function(eventName, callback, context) {\n    var self = this;\n    var wrappedCallback = function(data, sender) {\n      callback.call(this, data, sender);\n      self.off(eventName, wrappedCallback, context);\n    };\n    this.on(eventName, wrappedCallback, context);\n  },\n  \n  on: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).add(callback, context);\n  },\n  \n  off: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).remove(callback, context);\n  },\n  raise: function(eventName, data, sender) {\n    var container = this.eventListeners[eventName];\n\n    if(container)\n      container.raise(sender || this, data);\n\n    var proxies = this.proxies\n    for(var i = 0 ; i < proxies.length ; i++)\n      proxies[i].raise(eventName, data, sender || this)\n  },\n  addProxy: function(proxy) {\n    this.proxies.push(proxy)\n  },\n  removeProxy: function(proxy) {\n    this.proxies = _.without(this.proxies, proxy)\n  },\n  eventContainerFor: function(eventName) {\n    var container = this.eventListeners[eventName];\n    if(!container) {\n      container =  new EventContainer(this);\n      this.eventListeners[eventName] = container;\n    }\n    return container;\n  }\n};\n\nmodule.exports = Eventable;\n\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-events/eventable.js"
));

require.define("/node_modules/primo/node_modules/primo-events/node_modules/underscore/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"underscore.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-events/node_modules/underscore/package.json"
));

require.define("/node_modules/primo/node_modules/primo-events/node_modules/underscore/underscore.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     Underscore.js 1.4.3\n//     http://underscorejs.org\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // with specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    if (_.isEmpty(attrs)) return [];\n    return _.filter(obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + (0 | Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = '' + ++idCounter;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-events/node_modules/underscore/underscore.js"
));

require.define("/node_modules/primo/node_modules/primo-events/eventcontainer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore');\n\nvar EventContainer = function(defaultContext) {\n  this.handlers = [];\n  this.defaultContext = defaultContext;\n}; \n\nEventContainer.prototype = {\n  raise: function(source, data) {\n   var handlerLength = this.handlers.length;\n   var handlers = this.handlers\n   for(var i = 0; i < handlerLength; i++) {\n      var handler = handlers[i];\n      handler.method.call(handler.context || this.defaultContext, data, source);   \n   }\n  },\n  add: function(method, context) {\n    this.handlers.push({\n      method: method,\n      context: context      \n    });\n  },\n  remove: function(method, context) {\n    this.handlers = _(this.handlers).filter(function(item) {\n      return item.method !== method || item.context !== context;\n    });\n  }\n};\n  \nmodule.exports = EventContainer;\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-events/eventcontainer.js"
));

require.define("/node_modules/primo/node_modules/primo-timer/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"timer.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-timer/package.json"
));

require.define("/node_modules/primo/node_modules/primo-timer/timer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\n\nvar Timer = function(desiredFps) {\n  this.timeAtLastFrame = new Date().getTime()\n  this.idealTimePerFrame = 1000 / desiredFps\n  this.leftover = 0\n  this.scheduled = []\n  this.ticks = 0\n}\n\nTimer.prototype = {\n  tick: function(cb) {\n    var timeAtThisFrame = new Date().getTime()\n      , timeSinceLastTick = timeAtThisFrame - this.timeAtLastFrame + this.leftover\n      , catchUpFrameCount = Math.floor(timeSinceLastTick / this.idealTimePerFrame)\n\n    for(var i = 0; i < catchUpFrameCount; i++) {\n      cb()\n      this.ticks++\n      this.fireAnyScheduledEvents()\n    }\n\n    this.leftover = timeSinceLastTick - (catchUpFrameCount * this.idealTimePerFrame)\n    this.timeAtLastFrame = timeAtThisFrame\n  },\n  schedule: function(cb, ms) {\n    this.scheduled.push({\n      cb: cb,\n      ticks: this.ticks + Math.floor((ms / this.idealTimePerFrame))\n    })\n  },\n  clearSchedule: function() {\n    this.scheduled.length = 0\n  },\n  fireAnyScheduledEvents: function() {\n    var remaining = []\n    for(var i =0 ; i < this.scheduled.length; i++) {\n      var item = this.scheduled[i]\n      if(item.ticks <= this.ticks)\n        item.cb()\n      else\n        remaining.push(item)\n    }\n    this.scheduled = remaining\n  }\n}\n\nmodule.exports = Timer\n\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-timer/timer.js"
));

require.define("/node_modules/primo/node_modules/primo-timer/node_modules/underscore/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"underscore.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-timer/node_modules/underscore/package.json"
));

require.define("/node_modules/primo/node_modules/primo-timer/node_modules/underscore/underscore.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     Underscore.js 1.4.3\n//     http://underscorejs.org\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // with specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    if (_.isEmpty(attrs)) return [];\n    return _.filter(obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + (0 | Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = '' + ++idCounter;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-timer/node_modules/underscore/underscore.js"
));

require.define("/node_modules/primo/node_modules/primo-camera/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"camera.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-camera/package.json"
));

require.define("/node_modules/primo/node_modules/primo-camera/camera.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Camera = function(context, settings) {\r\n  settings = settings || {}\r\n  this.distance = 1000.0\r\n  this.lookat = [0,0]\r\n  this.context = context\r\n  this.fieldOfView = settings.fieldOfView || Math.PI / 4.0\r\n  this.viewport = {\r\n    left: 0,\r\n    right: 0,\r\n    top: 0,\r\n    bottom: 0,\r\n    width: 0,\r\n    height: 0,\r\n    scale: [1.0, 1.0]\r\n  }\r\n  this.updateViewport()\r\n}\r\n\r\nCamera.prototype = {\r\n  isVisible: function(x, y, width, height) {\r\n    if(x > this.viewport.right) return false\r\n    if(y > this.viewport.bottom) return false\r\n    if(x + width < this.viewport.left) return false\r\n    if(y + height < this.viewport.top) return false\r\n    return true\r\n  },\r\n  begin: function() {\r\n    this.context.save()\r\n    this.applyScale()\r\n    this.applyTranslation()\r\n  },\r\n  end: function() {\r\n    this.context.restore()\r\n  },\r\n  applyScale: function() {\r\n    this.context.scale(this.viewport.scale[0], this.viewport.scale[1])\r\n  },\r\n  applyTranslation: function() {\r\n    this.context.translate(-this.viewport.left, -this.viewport.top)\r\n  },\r\n  updateViewport: function() {\r\n    this.aspectRatio = this.context.canvas.width / this.context.canvas.height\r\n    this.viewport.width = this.distance * Math.tan(this.fieldOfView)\r\n    this.viewport.height = this.viewport.width / this.aspectRatio\r\n    this.viewport.left = this.lookat[0] - (this.viewport.width / 2.0)\r\n    this.viewport.top = this.lookat[1] - (this.viewport.height / 2.0)\r\n    this.viewport.right = this.viewport.left + this.viewport.width\r\n    this.viewport.bottom = this.viewport.top + this.viewport.height\r\n    this.viewport.scale[0] = this.context.canvas.width / this.viewport.width\r\n    this.viewport.scale[1] = this.context.canvas.height / this.viewport.height\r\n  },\r\n  zoomTo: function(z) {\r\n    this.distance = z\r\n    this.updateViewport()\r\n  },\r\n  move: function(x, y) {\r\n    this.lookat[0] += x \r\n    this.lookat[1] += y\r\n    this.updateViewport()\r\n  },\r\n  moveTo: function(x, y) {\r\n    this.lookat[0] = x\r\n    this.lookat[1] = y\r\n    this.updateViewport()\r\n  },\r\n  canvasToWorld: function(x, y, obj) {\r\n    obj = obj || {}\r\n    x -= this.context.canvas.offsetLeft\r\n    y -= this.context.canvas.offsetTop\r\n    obj.worldx = (x / this.viewport.scale[0]) + this.viewport.left\r\n    obj.worldy = (y / this.viewport.scale[1]) + this.viewport.top\r\n    return obj\r\n  },\r\n  worldToCanvas: function(x, y, obj) {\r\n    obj = obj || {}\r\n    obj.screenx = (x - this.viewport.left) * (this.viewport.scale[0])\r\n    obj.screeny = (y - this.viewport.top) * (this.viewport.scale[1])\r\n    obj.screenx += this.context.canvas.offsetLeft\r\n    obj.screeny += this.context.canvas.offsetTop\r\n    return obj      \r\n  },\r\n  makeTopLeftWorldCoords: function(x,y) {\r\n    this.lookat[0] = x + (this.viewport.width/2.0)\r\n    this.lookat[1] = x + (this.viewport.height/2.0)\r\n    this.updateViewport()\r\n  },\r\n  setViewport: function(x, y, width, height) {\r\n    this.distance = width / Math.tan(this.fieldOfView)\r\n    this.aspectRatio = width / height\r\n    this.updateViewport()\r\n    this.makeTopLeftWorldCoords(x, y)\r\n  },\r\n  scalex: function() {\r\n    return this.viewport.scale[0]\r\n  },\r\n  scaley: function() {\r\n    return this.viewport.scale[1]\r\n  }\r\n}\r\n\r\nmodule.exports = Camera\r\n  \r\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-camera/camera.js"
));

require.define("/node_modules/primo/lib/resources.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var SpriteMap = require('primo-spritemap')\nvar SoundResource = require('primo-audio')\nvar TextureResource = require('./textureresource')\n\nvar Resources = function() {\n  this.cache = {}\n  this.waitingForCount = 0\n}\n\nResources.prototype = {\n  spritemap: function(path, spritewidth, spriteheight) {\n    var image = this.image(path)\n    return new SpriteMap(image, spritewidth, spriteheight)\n  },\n  image: function(path) {\n    var resource = this.cache[path]\n    if(!resource) {\n      resource = new TextureResource(path)\n      this.cache[path] = resource\n      this.registerLoadingResource(resource)\n    }\n    return resource\n  },\n  sound: function(path) {\n    var resource = this.cache[path]\n    if(!resource) {\n      resource = new SoundResource(path)\n      this.cache[path] = resource\n      this.registerLoadingResource(resource)\n    }\n    return resource\n  },\n  registerLoadingResource: function(resource) {\n    this.waitingForCount++\n    resource.once('loaded', function() {\n      this.waitingForCount--\n    }, this)\n  }\n}\n\nmodule.exports = Resources\n\n\n//@ sourceURL=/node_modules/primo/lib/resources.js"
));

require.define("/node_modules/primo/node_modules/primo-spritemap/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"spritemap.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-spritemap/package.json"
));

require.define("/node_modules/primo/node_modules/primo-spritemap/spritemap.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar MemoryCanvas = require('primo-canvas')\nvar Eventable = require('primo-events')\n\nvar SpriteMap = function(texture, tilecountwidth, tilecountheight) {\n  Eventable.call(this)\n  this.tilewidth = 0\n  this.tileheight = 0\n  this.tilecountwidth = tilecountwidth || 1\n  this.tilecountheight = tilecountheight || 1\n  this.tilecount = tilecountwidth * tilecountheight \n  this.collisionmapsize = 0\n  this.collisionMaps = []\n  this.texture = texture\n  this.loaded = false\n  this.texture.waitForLoaded(_.bind(this.onLoaded, this))\n}\n\nSpriteMap.prototype = {\n  drawTo: function(context, index,  x, y, width, height, flipx, flipy, rotation) {\n    if(!this.loaded) return\n\n    var img = this.texture.get()\n\n    var rownumber = Math.floor(index / this.tilecountwidth)\n    var columnnumber = index % this.tilecountwidth\n\n    var sx = columnnumber * this.tilewidth\n    var sy = rownumber * this.tileheight\n\n    var scalex = flipx ? -1 : 1\n    var scaley = flipy ? -1 : 1\n    var contextSaved = false\n\n    if(rotation) {\n      if(!contextSaved) {\n        contextSaved = true\n        context.save()\n      }\n      context.translate(x + width/2.0, y + height/2.0)\n      context.rotate(rotation)\n      context.translate(-(x + width/2.0),-(y + height/2.0))\n    }\n\n    if(flipx || flipy) {\n      if(!contextSaved) {\n        contextSaved = true\n        context.save()\n      }\n      context.scale(scalex, scaley)\n      x *= scalex\n      y *= scaley\n      if(flipx)\n        x -= width\n      if(flipy)\n        y -= height\n      contextSaved = true\n    } \n\n\n    context.drawImage(img, \n      sx, sy, this.tilewidth, this.tileheight,\n      x, y , width || this.tilewidth, height || this.tileheight)\n\n    if(contextSaved) \n      context.restore()\n  },\n  generateCollisionMaps: function(width, height) {\n    if(!this.loaded) \n      return this.once('loaded', \n        function() { \n          this.generateCollisionMaps(width, height) }, this)\n\n    // TODO: This doesn't really belong here, it needs storing elsewhere or returning\n    this.collisionmapsize = width\n    var canvas = new MemoryCanvas(width, height)\n\n    try {\n      for(var i = 0; i < this.tilecount ; i++) {\n        canvas.reset()\n        this.drawTo(canvas.context, i, 0, 0, width, height)\n        this.collisionMaps[i] = canvas.createMap()\n      }\n    }\n    catch(ex) {\n      throw ex\n    }\n    finally {\n      canvas.dispose()\n    }\n  },\n  hasPixelAt: function(index, x, y) {\n    if(!this.loaded) return false\n    var map = this.collisionMaps[index]\n    return map[x + y * this.collisionmapsize]\n  },\n  onLoaded: function() {\n    this.loaded = true\n    var img = this.texture.get()\n    this.tilewidth = img.width / this.tilecountwidth\n    this.tileheight = img.height / this.tilecountheight\n    this.raise('loaded')\n  }\n}\n_.extend(SpriteMap.prototype, Eventable.prototype)\n\nmodule.exports = SpriteMap\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-spritemap/spritemap.js"
));

require.define("/node_modules/primo/node_modules/primo-canvas/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"memorycanvas.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-canvas/package.json"
));

require.define("/node_modules/primo/node_modules/primo-audio/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"primo-audio.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-audio/package.json"
));

require.define("/node_modules/primo/node_modules/primo-audio/primo-audio.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\n  , Eventable = require('primo-events')\n\nvar Sound = function(path) {\n  Eventable.call(this)\n\n  Sound.initSystem()\n  this.path = path\n  this.loadedPath = ''\n  this.rawdata = null\n  if(!Sound.Enabled) return\n  this.detectAudio()\n}\nSound.prototype = {\n  detectAudio: function() {\n    var attempts = [ loadmp3, loadogg, loadaac, loadwav ]\n    var self = this\n    var success = function(rawdata) {\n      self.rawdata = rawdata\n      self.raise('loaded')\n    }\n    var tryNext = function() {\n      if(attempts.length === 0) {\n        console.warn('Unable to load audio for ', self.path)\n        return\n      }\n      var fn = attempts.shift()\n      fn(self.path, success, tryNext)\n    }\n    tryNext()\n  },\n  play: function() {\n    if(!Sound.Enabled) return\n    var audio = this.getAudio()\n    audio.pause()\n    audio.currentTime = 0\n    try {\n      audio.play()\n    } catch (ex) {\n      this.raise('error', ex)\n    }\n  },\n  getAudio: function() {\n    return this.rawdata\n  }\n}\n_.extend(Sound.prototype, Eventable.prototype)\n\nSound.allowBase64 = false // Shouldn't be needed if I get everthing else right\nSound.initSystem = function() {\n  if(this.initialized) return\n  var a = document.createElement('audio')\n  this.Enabled = !!a.canPlayType\n  this.mp3 = !!(a.canPlayType && a.canPlayType('audio/mpeg;').replace(/no/, ''))\n  this.ogg = !!(a.canPlayType && a.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/no/, ''))\n  this.wav = !!(a.canPlayType && a.canPlayType('audio/wav; codecs=\"1\"').replace(/no/, ''))\n  this.aac = !!(a.canPlayType && a.canPlayType('audio/mp4; codecs=\"mp4a.40.2\"').replace(/no/, ''))\n}\n\nfunction downloadFile(path, cb) {\n  var xmlHttp = new XMLHttpRequest()\n  xmlHttp.onreadystatechange = function() {\n    if(xmlHttp.readyState === 4) {\n      cb(xmlHttp.responseText)\n    }\n  }\n  xmlHttp.open( \"GET\", path, true )\n  xmlHttp.send( null )\n}\n\n\n\nfunction handleAudioLoading(audio, cb) {\n\n  var force = function () {\n    audio.pause();\n    audio.removeEventListener('play', force, false);\n    if(cb) { cb(); cb = null; }\n  };\n\n  var progress = function () {\n    audio.removeEventListener('play', force, false);\n    audio.removeEventListener('progress', progress, false);\n    if(cb) { cb(); cb = null; }\n  };\n\n  audio.addEventListener('play', force, false);\n  audio.addEventListener('progress', progress, false);\n\n  var click = document.ontouchstart === undefined ? 'click' : 'touchstart';\n  var kickoff = function () {\n    audio.play();\n    document.documentElement.removeEventListener(click, kickoff, true);\n  };\n\n  document.documentElement.addEventListener(click, kickoff, true);\n}\n\nfunction tryBase64(mime, path, success, failure) {\n  if(!Sound.allowBase64) return failure()\n  downloadFile(path, function(data) {\n    if(!data) return failure\n    var audio = new Audio()\n    audio.src = mime + ';base64,' + data\n    handleAudioLoading(audio, function() {\n      success(audio)\n    })\n  })\n}\n\nfunction tryAudio(path, success, failure) {\n  var audio = new Audio()\n  try { \n    audio.src = path\n  } catch(ex) {\n    return failure()\n  }\n  handleAudioLoading(audio, function() {\n    success(audio)\n  })\n}\n\nfunction loadmp3(path, success, failure) {\n  if(!Sound.mp3) return failure()\n  tryBase64('data:audio/mp3', path + '.mp3.base64', success, function() {\n     tryAudio(path + '.mp3', success, failure)\n   })\n}\n\nfunction loadogg(path, success, failure) {\n  if(!Sound.ogg) return false\n  tryBase64('data:audio/ogg', path + '.ogg.base64', success, function() {\n    tryAudio(path + '.ogg', success, failure)\n  })\n}\nfunction loadaac(path, success, failure) {\n  if(!Sound.aac) return false\n  tryBase64('data:audio/mp4', path + '.mp4.base64', success, function() {\n     tryAudio(path + '.mp4', success, failure)\n  })\n}\n\nfunction loadwav(path, success, failure) {\n  if(!Sound.wav) return false\n  tryBase64('data:audio/wav', path + '.wav.base64', success, function() {\n   tryAudio(path + '.wav', success, failure)\n  })\n}\n\nmodule.exports = Sound\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-audio/primo-audio.js"
));

require.define("/node_modules/primo/node_modules/primo-audio/node_modules/underscore/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"underscore.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-audio/node_modules/underscore/package.json"
));

require.define("/node_modules/primo/node_modules/primo-audio/node_modules/underscore/underscore.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     Underscore.js 1.4.3\n//     http://underscorejs.org\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // with specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    if (_.isEmpty(attrs)) return [];\n    return _.filter(obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + (0 | Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = '' + ++idCounter;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-audio/node_modules/underscore/underscore.js"
));

require.define("/node_modules/primo/node_modules/primo-audio/node_modules/primo-events/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"eventable.js\"}\n//@ sourceURL=/node_modules/primo/node_modules/primo-audio/node_modules/primo-events/package.json"
));

require.define("/node_modules/primo/node_modules/primo-audio/node_modules/primo-events/eventable.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar EventContainer = require('./eventcontainer');\n  \nvar Eventable = function() {\n  this.eventListeners = {};\n  this.eventDepth = 0;\n  this.proxies = []\n};\n\nEventable.prototype = {\n  autoHook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.on(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  autoUnhook: function(container) {\n    for(var key in container) { \n      if(key.indexOf('on') === 0) {\n        this.off(key.substr(2), container[key], container);\n      }   \n    }\n  },\n  clearListeners: function() {\n    this.eventListeners = {};\n    this.eventDepth = 0;\n    this.proxies = []\n  },\n  once: function(eventName, callback, context) {\n    var self = this;\n    var wrappedCallback = function(data, sender) {\n      callback.call(this, data, sender);\n      self.off(eventName, wrappedCallback, context);\n    };\n    this.on(eventName, wrappedCallback, context);\n  },\n  \n  on: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).add(callback, context);\n  },\n  \n  off: function(eventName, callback, context) {\n    this.eventContainerFor(eventName).remove(callback, context);\n  },\n  raise: function(eventName, data, sender) {\n    var container = this.eventListeners[eventName];\n\n    if(container)\n      container.raise(sender || this, data);\n\n    var proxies = this.proxies\n    for(var i = 0 ; i < proxies.length ; i++)\n      proxies[i].raise(eventName, data, sender || this)\n  },\n  addProxy: function(proxy) {\n    this.proxies.push(proxy)\n  },\n  removeProxy: function(proxy) {\n    this.proxies = _.without(this.proxies, proxy)\n  },\n  eventContainerFor: function(eventName) {\n    var container = this.eventListeners[eventName];\n    if(!container) {\n      container =  new EventContainer(this);\n      this.eventListeners[eventName] = container;\n    }\n    return container;\n  }\n};\n\nmodule.exports = Eventable;\n\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-audio/node_modules/primo-events/eventable.js"
));

require.define("/node_modules/primo/node_modules/primo-audio/node_modules/primo-events/eventcontainer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore');\n\nvar EventContainer = function(defaultContext) {\n  this.handlers = [];\n  this.defaultContext = defaultContext;\n}; \n\nEventContainer.prototype = {\n  raise: function(source, data) {\n   var handlerLength = this.handlers.length;\n   var handlers = this.handlers\n   for(var i = 0; i < handlerLength; i++) {\n      var handler = handlers[i];\n      handler.method.call(handler.context || this.defaultContext, data, source);   \n   }\n  },\n  add: function(method, context) {\n    this.handlers.push({\n      method: method,\n      context: context      \n    });\n  },\n  remove: function(method, context) {\n    this.handlers = _(this.handlers).filter(function(item) {\n      return item.method !== method || item.context !== context;\n    });\n  }\n};\n  \nmodule.exports = EventContainer;\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-audio/node_modules/primo-events/eventcontainer.js"
));

require.define("/node_modules/primo/lib/textureresource.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\n  , Eventable = require('primo-events')\n\nvar TextureResource = function(path) {\n  Eventable.call(this)\n  this.path = path\n  this.loaded = false\n  this.image = new Image()\n  this.image.src = path\n  this.image.onload = _.bind(this.onLoaded, this)\n}\n\nTextureResource.prototype = {\n  get: function() {\n    return this.image\n  },\n  onLoaded: function() {\n    this.loaded = true\n    this.raise('loaded')\n  },\n  waitForLoaded: function(cb) {\n    if(this.loaded) cb()\n    else this.once('loaded', cb)\n  }\n}\n\n_.extend(TextureResource.prototype, Eventable.prototype)\n\nmodule.exports = TextureResource\n\n//@ sourceURL=/node_modules/primo/lib/textureresource.js"
));

require.define("/node_modules/primo/lib/input.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar Eventable = require('primo-events')\n\nvar Input = function(ele) {\n  Eventable.call(this)\n  document.addEventListener('keydown', _.bind(this.onKeyDown, this))\n  document.addEventListener('keyup', _.bind(this.onKeyUp, this))\n  this.aliases = {}\n  this.states = {}\n}\n\nInput.prototype = {\n  bind: function(keycode, alias) {\n    this.aliases[keycode] = alias\n  },\n  onKeyDown: function(e) {\n    var alias = this.aliases[e.keyCode]\n    if(alias) {\n      this.states[alias] = true\n    }\n    this.raise('keydown', e.keyCode)\n    return false\n  },\n  onKeyUp: function(e) {\n    var alias = this.aliases[e.keyCode]\n    if(alias) {\n      this.states[alias] = false\n    }\n    this.raise('keyup', e.keyCode)\n    return false\n  },\n  active: function(alias) {\n    return !!this.states[alias]\n  },\n  LEFT_ARROW: 37,\n  UP_ARROW: 38,\n  RIGHT_ARROW: 39,\n  DOWN_ARROW: 40,\n  LEFT_CTRL: 17,\n  RETURN: 13\n}\n\n_.extend(Input.prototype, Eventable.prototype)\n\nmodule.exports = Input\n\n\n//@ sourceURL=/node_modules/primo/lib/input.js"
));

require.define("/site/toolbar.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Eventable = require('primo-events')\nvar _ = require('underscore')\nvar LevelEditor = require('./leveleditor')\n\nvar Toolbar = function(editor) {\n  Eventable.call(this)\n  $('.dropdown-toggle').dropdown()\n  this.$newleveldialog = $('#new-level-dialog')\n  this.$listoflevels = $('#list-of-levels')\n  this.$listoflevels.on('click', 'a.level', _.bind(this.onLevelSelected,this))\n  this.$listoflevels.on('click', '#btn-save-level', _.bind(this.onLevelSave, this))\n  this.$listoflevels.on('click', '#btn-create-level', _.bind(this.onLevelCreate, this))\n  this.$newleveldialog.on('click', '.save', _.bind(this.onLevelCreateConfirmation, this))\n  this.levels = null\n  this.entities = null\n  this.editor = editor\n  $.getJSON('/levels', _.bind(this.onLevelsReceived, this))\n  $.getJSON('/entities', _.bind(this.onEntitiesReceived, this))\n}\n\nToolbar.prototype = {\n  onEntitiesReceived: function(entities) {\n    this.entities = entities\n    this.tryStart()\n  },\n  onLevelsReceived: function(levels) {\n    this.levels = levels\n    this.tryStart()\n  },\n  tryStart: function() {\n    if(this.levels && this.entities)\n      this.start()\n  },\n  start: function() {\n    for(var i = 0 ; i < this.levels.length; i++) {\n      var level = this.levels[i]\n      this.$listoflevels.append(\n        $('<li/>').html(\n          $('<a/>')\n            .attr('href', '#')\n            .addClass('level')\n            .text(level.name)\n            .data('level', level)\n        )\n      )\n    }\n  },\n  onLevelSelected: function(e) {\n    var level = $(e.target).data('level')\n    this.raise('level-selected', level.link)\n  },\n\n  onLevelSave: function() {\n    this.editor.save()\n  },\n  onLevelCreate: function() {\n    $('#new-level-dialog').modal()\n  },\n  onLevelCreateConfirmation: function() {\n    var self = this\n    var data = {\n      width: this.$newleveldialog.find(\"[name=width]\").val(),\n      height: this.$newleveldialog.find(\"[name=height]\").val(),\n      name: this.$newleveldialog.find(\"[name=name]\").val(),\n      tilesize: this.$newleveldialog.find(\"[name=tilesize]\").val(),\n    }\n    var url = \"/levels/\" + data.name + '.json'\n\n    $.ajax({\n        url: url,\n        type: \"PUT\",\n        contentType: \"application/json\",\n        data: JSON.stringify({\n          entityTypes: {},\n          entities: [],\n          layers: [],\n          width: data.width,\n          height: data.height,\n          tilesize: data.tilesize\n      }),\n      success: function() {\n        self.$newleveldialog.modal('hide')\n        self.raise('level-selected', url)\n      }\n    })\n  }\n}\n_.extend(Toolbar.prototype, Eventable.prototype)\n\nmodule.exports = Toolbar\n\n//@ sourceURL=/site/toolbar.js"
));

require.define("/site/leveleditor.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Eventable = require('primo-events')\nvar _ = require('underscore')\n\n// Should this be a standalone module?\nvar Level = {}; //require('../engine/level')\n\nvar LevelEditor = function(path) {\n  Eventable.call(this)\n  this.path = path\n  this.layers = []\n  this.level = new Level(path)\n  this.level.on('loaded', this.onLevelReceived, this)\n}\n\nLevelEditor.prototype = {\n  onLevelReceived: function() {\n    this.raise('loaded')\n  },\n  save: function() {\n    $.ajax({\n      type: \"PUT\",\n      url: this.path,\n      data: JSON.stringify(this.data),\n      contentType: \"application/json\"\n    })\n  },\n  createLayer: function(name, tileset) {\n    var tileData = this.createDataForNewLayer()\n    this.data.layers.push({\n      name: name,\n      tileset: tileset,\n      data: tileData\n    })\n    var self = this\n    require([tileset], function(data) {\n      self.level.layers.push({\n        name: name,\n        tileset: data,\n        data: tileData\n      })\n    })\n    this.raise('layer-added', this.layers[this.layers.length-1])\n  },\n  createDataForNewLayer: function() {\n    var data = []\n    for(var i =0 ; i < this.data.width; i++) {\n      for(var j = 0; j < this.data.height; j++) {\n        data.push(null)\n      }\n    }\n    return data\n  },\n}\n_.extend(LevelEditor.prototype, Eventable.prototype)\n\nmodule.exports = LevelEditor\n\n//@ sourceURL=/site/leveleditor.js"
));

require.define("/site/layers.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar Eventable = require('primo-events')\nvar EntityLayer = require('./entitylayer')\n\nvar Layers = function(editor) {\n  Eventable.call(this)\n  this.$layerselection = $('#layer-selection')\n  this.$addlayer = $('#btn-add-layer')\n  this.$newlayerdialog = $('#new-layer-dialog')\n  this.$newlayerdialog.on('click', '.save', _.bind(this.onLayerCreateRequest, this))\n  this.$selectedlayer = null\n  this.editor = editor\n  this.level = null\n  this.editor.on('level-changed', _.bind(this.onLevelChanged, this))\n  this.$layerselection.on('click', '.layer', _.bind(this.onLayerSelected, this))\n  this.$layerselection.on('click', '[name=layervisible]', _.bind(this.onLayerChecked, this))\n  this.$layerselection.on('click', '[name=collision]', _.bind(this.onCollisionChanged, this))\n  this.$addlayer.on('click', _.bind(this.onNewLayerClicked, this))\n}\n\nLayers.prototype = {\n  onLevelChanged: function(level) {\n    this.$layerselection.html('')\n    this.level = level\n\n    var self = this\n    this.level.forEachLayer(function(layer) {\n      self.addLayerUi(layer)\n    })\n    this.level.on('layer-added', _.bind(this.onLayerAdded, this))\n    this.selectLayerFromUi(this.$layerselection.find('li').eq(0))\n  },\n  onLayerAdded: function(layer) {\n    this.addLayerUi(layer)\n  },\n  addLayerUi: function(layer) {\n    this.$layerselection.append(\n      $('<li/>')\n        .addClass('layer')\n        .data('layer', layer)\n        .append(\n          $('<input type=\"checkbox\" name=\"layervisible\"/>')\n            .attr('checked', 'checked')\n        )\n        .append(\n          $('<span/>')\n          .text(layer.name())\n        )\n        .append(\n          $('<div/>').addClass('controls')\n          .append([\n            $('<label/>').attr('for', 'collision')\n                         .text('Collision'),\n\n            $('<input type=\"checkbox\" name=\"collision\"/>')\n                         .attr('checked', layer.iscollision() ? \"checked\" : false),\n          ])\n        )\n      )\n  },\n  onNewLayerClicked: function() {\n    this.updateTilesetList()\n    this.$newlayerdialog.modal()\n  },\n  updateTilesetList: function() {\n    $.getJSON('/tilesets', _.bind(this.onTilesetsReceived, this))\n  },\n  onTilesetsReceived: function(data) {\n    var $select = this.$newlayerdialog.find('[name=tileset]')\n    var $tilesets = []\n    for(var i = 0 ; i < data.length; i++) {\n      var tileset = data[i]\n      $tilesets.push(\n        $('<option/>')\n          .attr('value', tileset.link)\n          .text(tileset.name)\n        )\n    }\n    $select.html($tilesets)\n  },\n  onLayerCreateRequest: function() {\n    this.editor.createLayer(\n      this.$newlayerdialog.find('[name=name]').val(),\n      this.$newlayerdialog.find('[name=tileset]').val()\n    )\n    this.$newlayerdialog.modal('hide')\n  },\n  onLayerSelected: function(e) {\n    var $layer = $(e.target)\n    this.selectLayerFromUi($layer)\n  },\n  selectLayerFromUi: function($layer) {\n    if($layer.length === 0) return\n    var layerData = $layer.data('layer')\n    this.$layerselection.find('li').removeClass('selected')\n    this.selectedlayer = layerData\n    this.$selectedlayer = $layer\n    this.$selectedlayer.addClass('selected')\n    this.raise('layer-selected', layerData)\n  },\n  onCollisionChanged: function(e) {\n    e.stopImmediatePropagation()\n    var $checkbox = $(e.target)\n      , $layer = $checkbox.parents('.layer')\n      , layer = $layer.data('layer')\n    \n    layer.iscollision(!!$checkbox.attr('checked'))\n  },\n  onLayerChecked: function(e) {\n    e.stopImmediatePropagation()\n    var $checkbox = $(e.target)\n      , $layer = $checkbox.parent('.layer')\n      , layer = $layer.data('layer')\n    \n    if($checkbox.attr('checked'))\n      layer.show()\n    else\n      layer.hide()\n\n\n  }\n}\n_.extend(Layers.prototype, Eventable.prototype)\n\nmodule.exports = Layers\n\n//@ sourceURL=/site/layers.js"
));

require.define("/site/entitylayer.js",Function(['require','module','exports','__dirname','__filename','process','global'],"  var EntityLayer = function() {\n\n  }\n  EntityLayer.prototype = {\n    name: function() {\n      return \"Entities\"\n    }\n  }\n  module.exports = EntityLayer\n\n//@ sourceURL=/site/entitylayer.js"
));

require.define("/site/palette.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar TileTool = require('./tiletool')\nvar SelectTool = require('./selecttool')\n\nvar palettesize = 16\n\nvar Palette = function(editor) {\n  this.editor = editor\n  this.editor.layers.on('layer-selected', _.bind(this.onLayerSelected, this))\n  this.$selection = $('#palette-selection')\n  this.$selection.on('click', 'div', _.bind(this.onItemSelected, this))\n}\n\nPalette.prototype = {\n  onLayerSelected: function(layer) {\n    var items = [] \n    var tileset = layer.tileset()\n    var image = new Image()\n\n    var $selectTool = this.createItem(new SelectTool(), 'media/selecttool.png')\n    items.push($selectTool)\n\n    image.src = tileset.path\n    image.onload = _.bind(function() {\n      for(var i in tileset.tiles) {\n        var tileOffset = tileset.tiles[i]\n          , tilex = tileOffset % tileset.countwidth\n          , tiley = Math.floor(tileOffset / tileset.countheight)\n          , tilewidth = (image.width / tileset.countwidth)\n          , tileheight = tilewidth\n\n        var sx = tilex * palettesize\n        var sy = tiley * palettesize\n        var w = palettesize * tileset.countwidth\n        var h = palettesize * tileset.countheight\n\n        var tool = new TileTool(layer, tileOffset)\n        var $item = this.createItem(tool, layer.tileset().path)\n                        .css({ 'background-position': [\n                             -sx, 'px ', -sy, 'px'\n                           ].join(''),\n                            'background-size': [\n                              w, 'px ', h, 'px'\n                            ].join('')\n                         })\n\n        items.push($item)\n      }\n      this.$selection.html(items)\n    }, this)\n    this.select($selectTool)\n  },\n  createItem: function(tool, image, dimensions) {\n   return $('<div/>')\n        .css({\n          'background-image': ['url(', image, ')'].join(''),\n          'background-size': '16px 16px',\n          width: '16px',\n          height: '16px'\n        })\n        .data('tool', tool)\n  },\n  select: function($item) {\n    this.$selection.find('div').removeClass('selected')\n    $item.addClass('selected')\n    var tool = $item.data('tool')\n    this.editor.setActiveTool(tool)\n  },\n  onItemSelected: function(e) {\n    var $item = $(e.target)\n    this.select($item)\n  }\n}\n\nmodule.exports = Palette\n\n//@ sourceURL=/site/palette.js"
));

require.define("/site/tiletool.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\n\nvar TileTool = function(layer, tile) {\n  this.layer = layer\n  this.tile = tile\n  this.editor = null\n  this.onInputTap = _.bind(this.onInputTap, this)\n  this.onDragStart = _.bind(this.onDragStart, this)\n  this.onDrag = _.bind(this.onDrag, this)\n}\n\nTileTool.prototype = {\n  activate: function(editor) {\n    this.editor = editor\n    this.editor.input.cursor('pointer')\n    this.editor.input.on('tap', this.onInputTap)\n    this.editor.input.on('dragstart', this.onDragStart)\n    this.editor.input.on('drag', this.onDrag)\n  },\n  deactivate: function() {\n    this.editor.input.cursor('default')\n    this.editor.input.off('tap', this.onInputTap)\n    this.editor.input.off('dragstart', this.onDragStart)\n    this.editor.input.off('drag', this.onDrag)\n  },\n  onInputTap: function(ev) {\n    this.editor.executeAction(\n      new SetTileAction(ev.worldx, ev.worldy, this.layer, this.tile))\n  },\n  onDragStart: function(ev) {\n    this.editor.executeAction(\n      new SetTileAction(ev.worldx, ev.worldy, this.layer, this.tile))\n  },\n  onDrag: function(ev) {\n    this.editor.executeAction(\n      new SetTileAction(ev.worldx, ev.worldy, this.layer, this.tile))\n  }\n}\n\nvar SetTileAction = function(worldx, worldy, layer, tile) {\n  this.worldx = worldx\n  this.worldy = worldy\n  this.layer = layer\n  this.tile = tile\n  this.oldtile = null\n}\n\nSetTileAction.prototype = {\n  invoke: function() {\n    this.oldtile = this.layer.getTileAt(this.worldx, this.worldy)\n    this.layer.setTileAt(this.worldx, this.worldy, this.tile)\n  },\n  undo: function() {\n    this.layer.setTileAt(this.worldx, this.worldy, this.oldtile)\n  }\n}\n\nmodule.exports = TileTool\n\n//@ sourceURL=/site/tiletool.js"
));

require.define("/site/selecttool.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\n\nvar SelectTool = function() {\n  this.onInputTap = _.bind(this.onInputTap, this)\n  this.onDragStart = _.bind(this.onDragStart, this)\n  this.onDrag = _.bind(this.onDrag, this)\n  this.onDragEnd = _.bind(this.onDragEnd, this)\n}\n\nSelectTool.prototype = {\n  activate: function(editor) {\n    this.editor = editor\n    this.camera = this.editor.engine.camera\n    this.editor.input.cursor('pointer')\n    this.editor.input.on('tap', this.onInputTap)\n    this.editor.input.on('dragstart', this.onDragStart)\n    this.editor.input.on('drag', this.onDrag)\n    this.editor.input.on('dragend', this.onDragEnd)\n  },\n  deactivate: function() {\n    this.editor.input.cursor('default')\n    this.editor.input.off('tap', this.onInputTap)\n    this.editor.input.off('dragstart', this.onDragStart)\n    this.editor.input.off('drag', this.onDrag)\n    this.editor.input.off('dragend', this.onDragEnd)\n  },\n  onInputTap: function(ev) {\n    console.log(this.editor.level.solidAt(ev.worldx, ev.worldy))\n    var entity = this.editor.engine.entityAt(ev.worldx, ev.worldy)\n    this.editor.selectEntity(entity)\n  },\n  onDragStart: function(ev) {\n    console.log(ev.screenx, ev.screeny)\n    var start = this.camera.screenToWorld(\n      ev.screenx - ev.distancex,\n      ev.screeny - ev.distancey)\n    var entity = this.editor.engine.entityAt(start.worldx, start.worldy)\n    this.editor.selectEntity(entity)\n    if(entity)\n      this.startMovingEntity(ev, entity)\n    else\n      this.moveCamera(ev)\n  },\n  onDrag: function(ev) {\n    if(this.movingEntity)  \n      this.moveEntity(ev)\n    else\n      this.moveCamera(ev)\n  },\n  onDragEnd: function() {\n    this.movingEntity = null\n  },\n  moveEntity: function(ev) {\n    this.movingEntity.configuration({\n      x: this.movingEntity.x + ev.distancex / this.camera.scalex(),\n      y: this.movingEntity.y + ev.distancey / this.camera.scaley(),\n    })\n    this.editor.render()\n  },\n  moveCamera: function(ev) {\n    this.camera.move(-ev.distancex / this.camera.scalex(),\n                     -ev.distancey / this.camera.scaley())\n    this.editor.render()\n  },\n  startMovingEntity: function(ev, entity) {\n    this.movingEntity = entity\n    this.moveEntity(ev)\n  }\n}\nmodule.exports = SelectTool\n\n//@ sourceURL=/site/selecttool.js"
));

require.define("/site/input.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Eventable = require('primo-events')\nvar _ = require('underscore')\n\nvar Input = function(elementid, camera) {\n  Eventable.call(this)\n  this.element = document.getElementById(elementid)\n  this.camera = camera\n  this.hammer = new Hammer(this.element)\n  this.hammer.ontap = _.bind(this.onTap, this)\n  this.hammer.ondragstart = _.bind(this.onDragStart, this)\n  this.hammer.ondrag = _.bind(this.onDrag, this)\n  this.hammer.ondragend = _.bind(this.onDragEnd, this)\n  this.ev = {}\n  this.lastdistance = { x: 0, y: 0 }\n}\n\nInput.prototype = {\n  cursor: function(cursor) {\n    this.element.style.cursor = cursor\n  },\n  onTap: function(ev) {\n    this.camera.canvasToWorld(\n      ev.position[0].x,\n      ev.position[0].y,\n      this.ev\n    )\n    this.ev.screenx = ev.position[0].x\n    this.ev.screeny = ev.position[0].y\n    this.raise('tap', this.ev)\n  },\n  onDragStart: function(ev) {\n    this.camera.canvasToWorld(\n      ev.position.x + this.element.offsetLeft,\n      ev.position.y + this.element.offsetTop,\n      this.ev\n    )\n    this.ev.screenx = ev.position.x + this.element.offsetLeft\n    this.ev.screeny = ev.position.y + this.element.offsetTop\n    this.ev.distancex = ev.distanceX \n    this.ev.distancey = ev.distanceY\n    this.lastdistance.x = ev.distanceX\n    this.lastdistance.y = ev.distanceY\n    this.raise('dragstart', this.ev)\n  },\n  onDrag: function(ev) {\n    this.camera.canvasToWorld(\n      ev.position.x + this.element.offsetLeft,\n      ev.position.y + this.element.offsetTop,\n      this.ev\n    )\n    this.ev.screenx = ev.position.x + this.element.offsetLeft\n    this.ev.screeny = ev.position.y + this.element.offsetTop\n    this.ev.distancex = ev.distanceX - this.lastdistance.x \n    this.ev.distancey = ev.distanceY - this.lastdistance.y\n    this.lastdistance.x = ev.distanceX\n    this.lastdistance.y = ev.distanceY\n    this.raise('drag', this.ev)\n  },\n  onDragEnd: function(ev) {\n    this.raise('dragend')\n  }\n}\n_(Input.prototype).extend(Eventable.prototype)\n\nmodule.exports = Input\n\n//@ sourceURL=/site/input.js"
));

require.define("/site/entities.js",Function(['require','module','exports','__dirname','__filename','process','global'],"  var _ = require('underscore')\n    , Eventable = require('primo-events')\n    , MemoryCanvas = require('primo-canvas')\n    , EntityPlaceTool = require('./entityplacetool')\n\n  var Entities = function(editor) {\n    Eventable.call(this)\n    this.editor = editor\n    this.canvas = new MemoryCanvas(50,50)\n    this.$entities = $('#entity-selection')\n    this.populateEntities()\n    this.$entities.on('click', '.entity', _.bind(this.onEntitySelected, this))\n  }\n  Entities.prototype = {\n    populateEntities: function() {\n      $.getJSON('/entities', _.bind(this.onEntitiesReceived, this))\n    },\n    onEntitiesReceived: function(entities) {\n      for(var i =0 ; i < entities.length; i++) {\n        this.loadEntity(entities[i].link)\n      }\n    },\n    loadEntity: function(path) {\n      var self = this\n      require([path], function(Type) {\n        self.onEntityReceived(path, Type)\n      })\n    },\n    onEntityReceived: function(path, EntityType) {\n      var blah = new EntityType('editor', {x: 0, y: 0}, this.editor.engine)\n      this.canvas.setup(blah.width, blah.height)\n      blah.render(this.canvas.context)\n      var imageData = this.canvas.getImage()\n      this.$entities.append(\n        $('<img/>').attr('src', imageData)\n                   .attr('width', 25)\n                   .attr('height', 25)\n                   .addClass('entity')\n                   .data('tool', new EntityPlaceTool(\n                     path,\n                     EntityType\n                   ))\n      )\n    },\n    onEntitySelected: function(ev) {\n      var $entity = $(ev.target)\n      var tool = $entity.data('tool')\n      this.$entities.find('img').removeClass('selected')\n      this.$selectedentity = $entity\n      this.$selectedentity.addClass('selected')\n      this.editor.setActiveTool(tool)\n    }\n  }\n  _.extend(Entities.prototype, Eventable.prototype)\n\n  module.exports = Entities\n\n//@ sourceURL=/site/entities.js"
));

require.define("/node_modules/primo-canvas/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"memorycanvas.js\"}\n//@ sourceURL=/node_modules/primo-canvas/package.json"
));

require.define("/node_modules/primo-canvas/memorycanvas.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var MemoryCanvas = function(width, height) {\n  this.width = width\n  this.height = height\n  this.canvas = document.createElement('canvas')\n  this.canvas.width = width \n  this.canvas.height = height \n  this.context = this.canvas.getContext('2d')\n}\nMemoryCanvas.prototype = {\n  reset: function() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0)\n    this.context.clearRect(0,0, this.width, this.height)\n  },\n  setup: function(width, height) {\n    this.reset()\n\n    var scalex = this.width / width\n      , scaley = this.height / height\n\n    this.context.scale(scalex, scaley)\n  },\n  getImage: function() {\n    return this.canvas.toDataURL()\n  },\n  createMap: function() {\n    var data = this.context.getImageData(0,0, this.width, this.height).data\n    var map = new Array(this.width * this.height)\n    for(var y = 0; y < this.height; y++) {\n      for(var x = 0; x < this.width; x++) {\n        var index = x + y*this.width\n        var pixelindex = index * 4\n        var total = data[pixelindex] + data[pixelindex+1] + data[pixelindex+2]\n        if(total)\n          map[index] = 1\n        else\n          map[index] = 0\n      }\n    }\n    return map\n  },\n  dispose: function() {\n    document.removeElement(this.canvas)\n  }\n}\nmodule.exports = MemoryCanvas\n\n//@ sourceURL=/node_modules/primo-canvas/memorycanvas.js"
));

require.define("/site/entityplacetool.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EntityPlaceTool = function(path, Type) {\n  this.path = path\n  this.Type = Type\n  this.editor = null\n  this.trackedEntity = null\n  this.onInputTap = _.bind(this.onInputTap, this)\n  this.onDragStart = _.bind(this.onDragStart, this)\n  this.onDrag = _.bind(this.onDrag, this)\n}\nEntityPlaceTool.prototype = {\n  activate: function(editor) {\n    this.editor = editor\n    this.editor.input.cursor('pointer')\n    this.editor.input.on('tap', this.onInputTap)\n    this.editor.input.on('dragstart', this.onDragStart)\n    this.editor.input.on('drag', this.onDrag)\n  },\n  deactivate: function() {\n    this.editor.input.cursor('default')\n    this.editor.input.off('tap', this.onInputTap)\n    this.editor.input.off('dragstart', this.onDragStart)\n    this.editor.input.off('drag', this.onDrag)\n  },\n  onInputTap: function(ev) {\n    this.editor.addEntity(ev.worldx, ev.worldy, this.path, this.Type)\n  },\n  onDragStart: function(ev) {\n    this.trackedEntity = this.editor.addEntity(ev.worldx, ev.worldy, this.path, this.Type)\n  },\n  onDrag: function(ev) {\n    this.trackedEntity.configuration({\n      x: ev.worldx,\n      y: ev.worldy\n    })\n    this.editor.render()\n  }\n}\nmodule.exports = EntityPlaceTool\n\n//@ sourceURL=/site/entityplacetool.js"
));

require.define("/site/currentselection.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\n\nvar CurrentSelection = function(editor) {\n  this.editor = editor\n  this.editor.on('entity-selection-changed', _.bind(this.onEntitySelectionChanged,this))\n  this.editor.on('rendered', _.bind(this.onRender, this))\n  this.$selection = $('#selection-indicator')\n  this.$selection.css({\n      \"position\": \"absolute\",\n      \"border\": \"1px solid #0F0\",\n      \"pointer-events\": \"none\"\n  })\n\n  this.engine = this.editor.engine\n}\nCurrentSelection.prototype = {\n  onEntitySelectionChanged: function(entity) {\n    this.selectedEntity = entity\n  },\n  onRender: function() {\n    if(this.selectedEntity) {\n      var topleft = this.engine.camera.worldToScreen(\n        this.selectedEntity.x, this.selectedEntity.y)\n      var bottomright = this.engine.camera.worldToScreen(\n        this.selectedEntity.x + this.selectedEntity.width,\n        this.selectedEntity.y + this.selectedEntity.height)\n\n      this.$selection.css({\n        \"top\": topleft.screeny + \"px\",\n        \"left\": topleft.screenx + \"px\",\n        \"height\": (bottomright.screeny - topleft.screeny) + \"px\",\n        \"width\": (bottomright.screenx - topleft.screenx )+ \"px\"\n      })\n\n      this.$selection.show()\n    }\n    else {\n      this.$selection.hide()\n    }\n  }\n}\nmodule.exports = CurrentSelection\n\n//@ sourceURL=/site/currentselection.js"
));

require.define("/node_modules/primo/node_modules/primo-canvas/memorycanvas.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var MemoryCanvas = function(width, height) {\n  this.width = width\n  this.height = height\n  this.canvas = document.createElement('canvas')\n  this.canvas.width = width \n  this.canvas.height = height \n  this.context = this.canvas.getContext('2d')\n}\nMemoryCanvas.prototype = {\n  reset: function() {\n    this.context.setTransform(1, 0, 0, 1, 0, 0)\n    this.context.clearRect(0,0, this.width, this.height)\n  },\n  setup: function(width, height) {\n    this.reset()\n\n    var scalex = this.width / width\n      , scaley = this.height / height\n\n    this.context.scale(scalex, scaley)\n  },\n  getImage: function() {\n    return this.canvas.toDataURL()\n  },\n  createMap: function() {\n    var data = this.context.getImageData(0,0, this.width, this.height).data\n    var map = new Array(this.width * this.height)\n    for(var y = 0; y < this.height; y++) {\n      for(var x = 0; x < this.width; x++) {\n        var index = x + y*this.width\n        var pixelindex = index * 4\n        var total = data[pixelindex] + data[pixelindex+1] + data[pixelindex+2]\n        if(total)\n          map[index] = 1\n        else\n          map[index] = 0\n      }\n    }\n    return map\n  },\n  dispose: function() {\n    // TODO: Er, work out if I have to do anything to avoid leaks here??\n  }\n}\nmodule.exports = MemoryCanvas\n\n//@ sourceURL=/node_modules/primo/node_modules/primo-canvas/memorycanvas.js"
));

require.define("/node_modules/primo/lib/scene.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var _ = require('underscore')\nvar Eventable = require('primo-events')\nvar Camera = require('primo-camera')\n\nvar Scene = function(game) {\n  Eventable.call(this)\n  this.entities = []\n  this.layers = []\n  this.game = game\n  this.context = this.game.context\n  this.camera = new Camera(this.context)\n  this.camera.makeTopLeftWorldCoords(0,0)\n  this.gravityObject = {x: 0, y: 0}\n}\n\nScene.prototype = {\n  tick: function(frameTime) {\n    for(var i = 0; i < this.entities.length; i++) { \n      var entity = this.entities[i] \n      entity.tick(frameTime)\n      entity.applyPhysics(frameTime)\n    }\n  },\n  applyGravityTo: function(entity) {\n    if(!entity.gravible) return\n    this.gravityObject.x = 0\n    this.gravityObject.y = 0\n    this.game.gravity(entity, this.gravityObject)\n    entity.velx += this.gravityObject.x\n    entity.vely += this.gravityObject.y\n  },\n  render: function(context) {\n    this.camera.begin()\n    this.raise('pre-render', this.context)\n    try {\n      this.forEachVisibleEntity(function(entity) {\n        entity.render(context)\n      })\n    }\n    catch(ex) {\n      console.log(\"problem rendering scene\", ex)\n    }\n    finally {\n      this.raise('post-render', this.context)\n      this.camera.end()\n    }\n  },\n  reset: function() {\n    this.entities = []\n    this.clearListeners()\n    this.layers = []\n  },\n  findEntityById: function(id) {\n    return _.find(this.entities, function(entity) { return entity.id === id })\n  },\n  spawnEntity: function(Type, data)  {\n    var entity = new Type('entity-' + this.entities.length, data, this)\n    this.entities.push(entity)\n    entity.addProxy(this)\n    return entity\n  },\n  forEachEntity: function(cb) {\n    for(var i = 0; i < this.entities.length; i++) {\n      cb(this.entities[i])\n    }\n  },\n  forEachVisibleEntity: function(cb) {\n    var camera = this.camera\n    this.forEachEntity(function(entity) {\n      if(camera.isVisible(entity.x, entity.y, entity.width, entity.height)) cb(entity)\n    })\n  },\n  removeEntity: function(entity) {\n    entity.removeProxy(this)\n    this.entities = _.without(this.entities, entity)\n  },\n  addLayer: function(layer) {\n    this.layers.push(layer)\n  },\n  entityAt: function(worldx, worldy) {\n    for(var i = 0; i < this.entities.length; i++) {\n      var entity = this.entities[i]\n      if(entity.x > worldx) continue\n      if(entity.y > worldy) continue\n      if(entity.x + entity.width < worldx) continue\n      if(entity.y + entity.height < worldy) continue\n      return entity\n    }\n    return null\n  },\n  renderLayer: function(layer) {\n    layer.render(this.context)\n  },\n}\n_.extend(Scene.prototype, Eventable.prototype)\n\nmodule.exports = Scene\n\n\n//@ sourceURL=/node_modules/primo/lib/scene.js"
));

require.define("/node_modules/primo/lib/game.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Eventable = require('primo-events')\nvar Timer = require('primo-timer')\n\nvar _ = require('underscore')\n\nvar Scene = require('./scene')\nvar Resources = require('./resources')\nvar Input = require('./input')\n\nvar Game = function(targetId) {\n  Eventable.call(this)\n  this.targetid = targetId\n  this.desiredFps = 30\n  this.cellsize = 32\n  this.gravity = function() {}\n  this.frameTime = 1 / this.desiredFps\n  this.tickTimer = new Timer(this.desiredFps)\n  this.tick = _.bind(this.tick, this)\n  this.canvas = document.getElementById(this.targetid)\n  this.context = this.canvas.getContext('2d')\n  this.scene = new Scene(this)\n  this.resources = new Resources()\n  this.input = new Input(this.canvas)\n}\n\nGame.prototype = {\n  reset: function() {\n    this.scene.reset()\n    this.tickTimer.clearSchedule()\n  },\n  start: function() {\n    this.raise('init')\n    setInterval(_.bind(this.doTick, this), this.frameTime * 1000)\n  },\n  doTick: function() {\n    this.tickTimer.tick(this.tick)\n    this.render()\n  },\n  tick: function() {\n    this.raise('PreTick', this.frameTime) \n    this.scene.tick(this.frameTime)\n    this.raise('PostTick', this.frameTime) \n  },\n  render: function() {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    this.scene.render(this.context)\n  },\n  scheduleEvent: function(ev, ms) {\n    this.tickTimer.schedule(ev, ms)\n  }\n}\n\n_.extend(Game.prototype, Eventable.prototype)\n\nmodule.exports = Game\n\n//@ sourceURL=/node_modules/primo/lib/game.js"
));

require.define("/node_modules/primo-level/level.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Eventable = require('primo-events')\n  , _ = require('underscore')\n  , SpriteMap = require('primo-spritemap')\n  , Layer = require('./layer')\n  , request = require('browser-request')\n\nvar Level = function(engine, path) {\n  Eventable.call(this)\n  this.path = path\n  this.rawdata = null\n  this.tilesets = {}\n  this.spritemaps = {}\n  this.entityTypes = {}\n  this.pendingResults = 0\n  this.finished = false\n  this.engine = engine\n  this.load()\n}\n\nLevel.prototype = {\n  loadInto: function(scene) {\n    scene.reset()\n    scene.on('pre-render', this.render, this)\n    var i = 0\n    for(i = 0; i < this.rawdata.entities.length; i++) {\n      var config = this.rawdata.entities[i]\n      var type = this.entityTypes[config.type]\n      scene.spawnEntity(type, config.data)\n    }\n  },\n  render: function(context) {\n    for(var i = 0; i < this.layers.length; i++) \n      this.layers[i].render(context)\n  },\n  width: function() {\n    return this.rawdata.width\n  },\n  height: function() {\n    return this.rawdata.height\n  },\n  tilesize: function() {\n    return this.rawdata.tilesize\n  },\n  layerdata: function(index) {\n    return this.rawdata.layers[index]\n  },\n  tileset: function(name) {\n    return this.tilesets[name]\n  },\n  spritemap: function(name) {\n    return this.spritemaps[name]\n  },\n  load: function() {\n    $.getJSON(this.path, _.bind(this.onLevelReceived, this))\n  },\n  worldToTile: function(world) {\n    return Math.floor(world / this.rawdata.tilesize)\n  },\n  checkQuadMovement: function(x, y, width, height, velx, vely, res) {\n    var steps = Math.ceil(Math.max(Math.abs(velx), Math.abs(vely)))\n    var stepx = velx / steps\n    var stepy = vely / steps\n    res = res || {}\n\n    var topleft = false, \n        topright = false, \n        bottomleft = false, \n        bottomright = false \n\n    for(var i = 0 ; i < steps ; i++) {\n      var offsetx = stepx * i\n      var offsety = stepy * i\n\n      if(this.solidAt(x + offsetx, y + offsety))\n        topleft = true\n\n      if(this.solidAt(x + offsetx + width, y + offsety))\n        topright = true\n\n      if(this.solidAt(x + offsetx, y + offsety + height))\n        bottomleft = true\n\n      if(this.solidAt(x + offsetx + width, y + offsety + height))\n        bottomright = true\n\n      if(topleft || topright || bottomleft || bottomright) {\n        res.x = x + offsetx - stepx\n        res.y = y + offsety - stepy\n\n        if(bottomleft && bottomright)\n          res.horizontal = true\n        if(topleft && topright)\n          res.horizontal = true\n        if(topright && bottomright)\n          res.vertical = true\n        if(topleft && bottomleft)\n          res.vertical = true\n\n        res.collision = true\n\n        break\n      }\n    }\n    return res\n  },\n  solidAt: function(worldx, worldy) {\n    var x = parseInt(worldx, 10)\n    var y = parseInt(worldy, 10)\n    if(x < 0) return false\n    if(y < 0) return false\n    if(x >= this.width() * this.rawdata.tilesize) return false\n    if(y >= this.height() * this.rawdata.tilesize) return false\n\n    for(var i = 0 ; i < this.layers.length; i++) {\n      var layer = this.layers[i]\n      if(layer.iscollision() && layer.solidAt(x, y)) return true\n    }\n    return false\n  },\n  layerCount: function() {\n    return this.data.layers.length\n  },\n  onLevelReceived: function(rawdata) {\n    this.rawdata = rawdata\n    this.tilesets = {}\n    this.entityTypes = {}\n    this.layers = []\n    this.loadLayers()\n    this.loadEntities()\n    this.finished = true\n    this.tryFinish()\n  },\n  loadLayers: function() {\n    for(var i = 0 ; i < this.rawdata.layers.length; i++) \n      this.loadLayer(i)\n  },\n  addLayer: function(data) {\n    var i = this.rawdata.layers.length\n    this.rawdata.layers.push(data)\n    this.layers.push(new Layer(this, i))\n    this.loadLayer(i)\n  },\n  loadLayer: function(i) {\n    var layer = this.rawdata.layers[i]\n    var tilesets = this.tilesets\n    var spritemaps = this.spritemaps\n    var collisionmaps = this.collisionmaps\n    var tilesize = this.tilesize()\n    var engine = this.engine\n\n    this.getJson(layer.tileset, function(tileset) {\n      tilesets[layer.tileset] = tileset\n      spritemaps[layer.tileset] = \n        engine.resources.spritemap(tileset.path, tileset.countwidth, tileset.countheight)\n      spritemaps[layer.tileset].generateCollisionMaps(tileset.tilesize, tileset.tilesize)\n    })\n  },\n  loadEntities: function() {\n    for(var key in this.rawdata.entityTypes)  {\n      this.loadEntity(key)\n    }\n  },\n  loadEntity: function(key) {\n    var path = this.rawdata.entityTypes[key]\n    var entities = this.entityTypes\n    this.require(path, function(type) {\n      entities[key] = type\n    })\n  },\n\n  getJson: function(dep, callback) {\n    var self = this\n    this.pendingResults++\n    request(dep, function(err, response, body) {\n      callback(JSON.parse(body))\n      self.pendingResults--\n      self.tryFinish()\n    })\n  },\n\n  tryFinish: function() {\n    if(this.pendingResults === 0 && this.finished) {\n      this.createLayers()\n      this.raise('loaded')\n    }\n  },\n  createLayers: function() {\n    for(var i = 0 ; i < this.rawdata.layers.length; i++) {\n      this.layers[i] = new Layer(this, i)\n    }\n  },\n  forEachLayer: function(cb) {\n    for(var i = 0 ; i < this.layers.length; i++) {\n      cb(this.layers[i])\n    }\n  },\n  indexForWorldCoords: function(x, y) {\n    var tilex = Math.floor(x / this.rawdata.tilesize)\n    var tiley = Math.floor(y / this.rawdata.tilesize)\n    var index = tilex + tiley * this.rawdata.width\n    return index\n  },\n  setTileAt: function(layer, x, y, tile) {\n    var index = this.indexForWorldCoords(x, y)\n    this.rawdata.layers[layer].data[index] = tile\n  },\n  getTileAt: function(layer, x, y, tile) {\n    var index = this.indexForWorldCoords(x, y)\n    return this.rawdata.layers[layer].data[index] \n  }\n}\n\n_.extend(Level.prototype, Eventable.prototype)\n\nmodule.exports = Level\n\n\n//@ sourceURL=/node_modules/primo-level/level.js"
));

require.define("/site/main.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Eventable = require('primo-events')\n  , Level = require('primo-level')\n  , Primo = require('primo')\n  , _ = require('underscore')\n  , Toolbar = require('./toolbar')\n  , Layers = require('./layers')\n  , Palette = require('./palette')\n  , Input = require('./input')\n  , Entities = require('./entities')\n  , CurrentSelection = require('./currentselection')\n\nvar Editor = function(targetid) {\n  Eventable.call(this)\n  this.targetid = targetid\n  this.level = null\n  this.selectedEntity = null\n  this.engine = Primo.Create(targetid)\n  this.toolbar = new Toolbar(this)\n  this.layers = new Layers(this)\n  this.palette = new Palette(this)\n  this.entities = new Entities(this)\n  this.selection = new CurrentSelection(this)\n  this.input = new Input(targetid, this.engine.scene.camera)\n  this.toolbar.on('level-selected', _.bind(this.onLevelSelected, this))\n  this.activeTool = null\n  this.$leveltitle = $('.level-title')\n  setInterval(_.bind(this.render, this), 500)\n}\n\nEditor.prototype = {\n  render: function() {\n    this.engine.render()\n    this.raise('rendered')\n  },\n  selectEntity: function(entity) {\n    this.selectedEntity = entity\n    this.raise('entity-selection-changed', entity)\n  },\n  onLevelSelected: function(path) {\n    this.level = new Level(this.engine, path)\n    this.level.on('loaded', this.onLevelLoaded, this)\n  },\n  onLevelLoaded: function() {\n    this.level.loadInto(this.engine.scene);\n    this.$leveltitle.text(this.level.path)\n    this.raise('level-changed', this.level)\n  },\n  setActiveTool: function(tool) {\n    if(this.activeTool)\n      this.activeTool.deactivate()\n    this.activeTool = tool\n    if(this.activeTool)\n      this.activeTool.activate(this)\n  },\n  executeAction: function(action) {\n    action.invoke()\n    this.render()\n  },\n  /*\n   * Yes, this is a leaky bit of cover up around 'level'\n   * I'll sleep on it\n   */\n  loadIntoGame: function(game) {\n    game.reset()\n    for(var i = 0; i < this.level.rawdata.entities.length; i++) {\n      var config = this.level.rawdata.entities[i]\n      var type = this.level.entityTypes[config.type]\n      var entity = game.spawnEntity(type, config.data)\n      this.hookEntity(entity, config)\n    }\n  },\n  forEachLayer: function(cb) {\n    this.level.forEachLayer(cb)\n  },\n  createEntityData: function(x, y, path, Type) {\n    var type = this.registerEntityType(path, Type)\n    var entityData =  {\n      type: type,\n      data: {\n        x: x,\n        y: y\n      }\n    }\n    this.level.rawdata.entities.push(entityData)\n    return entityData\n  },\n  registerEntityType: function(path, Type) {\n    var lastSlash = path.lastIndexOf('/')\n    var type = path.substr(lastSlash+1, path.length - (lastSlash+1))\n    this.level.entityTypes[type] = Type\n    this.level.rawdata.entityTypes[type] = path\n    return type\n  },\n  hookEntity: function(entity, config) {\n    entity.configuration = function(data) {\n      if(data)\n        config.data = data\n      if(data.x) entity.x = data.x\n      if(data.y) entity.y = data.y\n      return config.data\n    }\n  },\n  addEntity: function(x, y, path, Type) {\n    var rawdata = this.createEntityData(x,y,path,Type)\n    var entity = this.engine.spawnEntity(Type, {\n      x: x,\n      y: y\n    })\n    this.hookEntity(entity, rawdata)\n    return entity\n  },\n  createLayer: function(name, tileset) {\n    this.level.addLayer({\n      data: this.createDataForNewLayer(),\n      tileset: tileset,\n      name: name\n    })\n    this.raise('layer-added')\n  },\n  createDataForNewLayer: function() {\n    var data = []\n    for(var i =0 ; i < this.level.width(); i++) {\n      for(var j = 0; j < this.level.height() ; j++) {\n        data.push(null)\n      }\n    }\n    return data\n  },\n  /* * * * * * * * * * *  * */\n\n  getTileAt: function(layer, x, y) {\n    return this.levelEditor.getTileAt(layer, x, y)\n  },\n  setTileAt: function(layer, x, y, tile) {\n    this.levelEditor.setTileAt(layer, x, y, tile)\n  },\n  save: function()  {\n    $.ajax({\n      type: \"PUT\",\n      url: this.level.path,\n      data: JSON.stringify(this.level.rawdata),\n      contentType: \"application/json\"\n    })\n  }\n}\n_.extend(Editor.prototype, Eventable.prototype)\n\nvar editor = new Editor('target')\n\n//@ sourceURL=/site/main.js"
));
require("/site/main.js");
})();
